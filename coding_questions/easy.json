[
  {
    "id": "E001",
    "title": "Two Sum",
    "slug": "two-sum",
    "difficulty": "Easy",
    "points": 100,
    "topics": ["Array", "Hash Table"],
    "tags": ["hash-map", "lookup"],
    "statement_markdown": "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.",
    "input_format": "Line 1: Space-separated integers representing the array\nLine 2: Target integer",
    "output_format": "Two space-separated integers representing the indices",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists"
    ],
    "time_limit_ms": 1000,
    "memory_limit_mb": 256,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[2,7,11,15], 9], "output": [0,1], "type": "public"},
      {"input": [[3,2,4], 6], "output": [1,2], "type": "public"},
      {"input": [[3,3], 6], "output": [0,1], "type": "hidden"},
      {"input": [[-1,-2,-3,-4], -8], "output": [2,3], "type": "hidden"},
      {"input": [[1,2], 3], "output": [0,1], "type": "edge"},
      {"input": [[0,4,3,0], 0], "output": [0,3], "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 30,
      "hidden_testcase_points": 70,
      "timeout_penalty": -50
    },
    "canonical_solution": {
      "Python": {
        "code": "def two_sum(nums, target):\n    num_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in num_map:\n            return [num_map[complement], i]\n        num_map[num] = i\n    return []",
        "time_complexity": "O(n)",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use a hash map to store each number and its index as we iterate through the array. For each number, check if its complement (target - current number) exists in the hash map.",
    "hints": [
      "Think about what you need to find for each number",
      "Consider using a hash map to store previously seen numbers",
      "You only need one pass through the array"
    ],
    "difficulty_score": 1200,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "E002",
    "title": "Remove Duplicates from Sorted Array",
    "slug": "remove-duplicates-from-sorted-array",
    "difficulty": "Easy",
    "points": 100,
    "topics": ["Array", "Two Pointers"],
    "tags": ["in-place", "two-pointers", "sorted-array"],
    "statement_markdown": "Given an integer array `nums` sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array `nums`. More formally, if there are `k` elements after removing the duplicates, then the first `k` elements of `nums` should hold the final result.\n\nReturn `k` after placing the final result in the first `k` slots of `nums`.",
    "input_format": "Sorted array of integers",
    "output_format": "Length of array after removing duplicates",
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-100 <= nums[i] <= 100",
      "nums is sorted in non-decreasing order"
    ],
    "time_limit_ms": 1000,
    "memory_limit_mb": 256,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,1,2]], "output": 2, "type": "public"},
      {"input": [[0,0,1,1,1,2,2,3,3,4]], "output": 5, "type": "public"},
      {"input": [[1]], "output": 1, "type": "hidden"},
      {"input": [[1,1,1]], "output": 1, "type": "hidden"},
      {"input": [[1,2,3]], "output": 3, "type": "edge"},
      {"input": [[-1,0,0,0,3,3]], "output": 3, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 30,
      "hidden_testcase_points": 70,
      "timeout_penalty": -50
    },
    "canonical_solution": {
      "Python": {
        "code": "def removeDuplicates(nums):\n    if not nums:\n        return 0\n    slow = 0\n    for fast in range(1, len(nums)):\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    return slow + 1",
        "time_complexity": "O(n)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "Use two pointers: slow pointer tracks position to place next unique element, fast pointer scans the array. When elements differ, advance slow pointer and copy element.",
    "hints": [
      "Use two pointers approach",
      "Since array is sorted, duplicates are adjacent",
      "Keep track of where to place the next unique element"
    ],
    "difficulty_score": 1100,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "E003",
    "title": "Maximum Sum Subarray of Size K",
    "slug": "maximum-sum-subarray-size-k",
    "difficulty": "Easy",
    "points": 100,
    "topics": ["Array", "Sliding Window"],
    "tags": ["sliding-window", "subarray", "maximum-sum"],
    "statement_markdown": "Given an array of integers `nums` and an integer `k`, find the maximum sum of any contiguous subarray of size `k`.\n\nReturn the maximum sum.",
    "input_format": "Line 1: Array of integers\nLine 2: Integer k (subarray size)",
    "output_format": "Maximum sum of subarray of size k",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "1 <= k <= nums.length",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "time_limit_ms": 1000,
    "memory_limit_mb": 256,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,12,-5,-6,50,3], 4], "output": 51, "type": "public"},
      {"input": [[2,1,5,1,3,2], 3], "output": 9, "type": "public"},
      {"input": [[1,2,3], 1], "output": 3, "type": "hidden"},
      {"input": [[-1,-2,-3], 2], "output": -3, "type": "hidden"},
      {"input": [[5], 1], "output": 5, "type": "edge"},
      {"input": [[1,1,1,1], 4], "output": 4, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 30,
      "hidden_testcase_points": 70,
      "timeout_penalty": -50
    },
    "canonical_solution": {
      "Python": {
        "code": "def maxSubarraySum(nums, k):\n    if len(nums) < k:\n        return 0\n    \n    # Calculate sum of first window\n    window_sum = sum(nums[:k])\n    max_sum = window_sum\n    \n    # Slide the window\n    for i in range(k, len(nums)):\n        window_sum = window_sum - nums[i-k] + nums[i]\n        max_sum = max(max_sum, window_sum)\n    \n    return max_sum",
        "time_complexity": "O(n)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "Use sliding window technique: calculate sum of first k elements, then slide the window by removing the leftmost element and adding the new rightmost element.",
    "hints": [
      "Use sliding window technique",
      "Calculate the first window sum, then slide efficiently",
      "Only need to add/remove one element at a time"
    ],
    "difficulty_score": 1200,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "E004",
    "title": "Valid Palindrome",
    "slug": "valid-palindrome", 
    "difficulty": "Easy",
    "points": 100,
    "topics": ["Two Pointers", "String"],
    "tags": ["palindrome", "two-pointers", "string-processing"],
    "statement_markdown": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` if it is a palindrome, or `false` otherwise.",
    "input_format": "String s",
    "output_format": "Boolean true/false",
    "constraints": [
      "1 <= s.length <= 2 * 10^5",
      "s consists only of printable ASCII characters"
    ],
    "time_limit_ms": 1000,
    "memory_limit_mb": 256,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": ["A man, a plan, a canal: Panama"], "output": true, "type": "public"},
      {"input": ["race a car"], "output": false, "type": "public"},
      {"input": [""], "output": true, "type": "hidden"},
      {"input": ["a"], "output": true, "type": "hidden"},
      {"input": ["Madam"], "output": true, "type": "edge"},
      {"input": ["No 'x' in Nixon"], "output": true, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 30,
      "hidden_testcase_points": 70,
      "timeout_penalty": -50
    },
    "canonical_solution": {
      "Python": {
        "code": "def isPalindrome(s):\n    # Convert to lowercase and keep only alphanumeric\n    cleaned = ''.join(c.lower() for c in s if c.isalnum())\n    return cleaned == cleaned[::-1]",
        "time_complexity": "O(n)",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use two pointers from both ends. Skip non-alphanumeric characters and compare remaining characters in lowercase.",
    "hints": [
      "Use two pointers from start and end",
      "Skip non-alphanumeric characters", 
      "Convert to lowercase for comparison"
    ],
    "difficulty_score": 1200,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "E005",
    "title": "Is Prime Number",
    "slug": "is-prime-number",
    "difficulty": "Easy",
    "points": 100,
    "topics": ["Math", "Number Theory"],
    "tags": ["prime", "math", "optimization"],
    "statement_markdown": "A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n\nGiven a positive integer `n`, return `true` if `n` is a prime number, or `false` otherwise.",
    "input_format": "Positive integer n",
    "output_format": "Boolean true/false",
    "constraints": [
      "1 <= n <= 10^6"
    ],
    "time_limit_ms": 1000,
    "memory_limit_mb": 256,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [2], "output": true, "type": "public"},
      {"input": [4], "output": false, "type": "public"},
      {"input": [1], "output": false, "type": "hidden"},
      {"input": [17], "output": true, "type": "hidden"},
      {"input": [97], "output": true, "type": "edge"},
      {"input": [100], "output": false, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 30,
      "hidden_testcase_points": 70,
      "timeout_penalty": -50
    },
    "canonical_solution": {
      "Python": {
        "code": "def isPrime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
        "time_complexity": "O(sqrt(n))",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "Check divisibility up to sqrt(n). Optimize by checking 2,3 first, then only numbers of form 6k±1.",
    "hints": [
      "Numbers <= 1 are not prime",
      "Only need to check up to sqrt(n)",
      "Optimize by checking only 6k±1 form numbers"
    ],
    "difficulty_score": 1300,
    "created_by": "system",
    "status": "active"
  }
]