[
  {
    "id": "M001",
    "title": "Binary Search: Search in Rotated Sorted Array",
    "slug": "search-rotated-sorted-array",
    "difficulty": "Medium",
    "points": 3000,
    "topics": ["Binary Search", "Array Manipulation", "Divide and Conquer"],
    "tags": ["binary-search", "rotated-array", "divide-conquer", "pivot-detection"],
    "statement_markdown": "Master **rotated array search**:\n\n1. **Pivot Detection**: Find rotation point in sorted array\n2. **Modified Binary Search**: Adapt search for rotated structure\n3. **Boundary Handling**: Handle edge cases and duplicates\n4. **Range Analysis**: Determine which half contains target\n5. **Optimization**: Achieve O(log n) time complexity\n\nImplement efficient search in rotated sorted arrays.",
    "input_format": "Rotated sorted array, target value, search parameters",
    "output_format": "Target index or -1 if not found, search path analysis",
    "constraints": [
      "1 <= n <= 10^4 (array length)",
      "1 <= nums[i] <= 10^6",
      "Array rotated at unknown pivot",
      "All elements unique",
      "Target may or may not exist"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[4,5,6,7,0,1,2], 0], "output": 4, "type": "public"},
      {"input": [[4,5,6,7,0,1,2], 3], "output": -1, "type": "public"},
      {"input": [[1], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,3], 3], "output": 1, "type": "edge"},
      {"input": [[3,1], 1], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def search_rotated(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1",
        "time_complexity": "O(log n)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "The key insight is that one half of a rotated sorted array is always sorted. We identify the sorted half and check if the target lies within its range.",
    "hints": [
      "Identify which half (left or right) is properly sorted",
      "Check if target lies within the sorted half's range",
      "Use standard binary search logic for the sorted portion"
    ],
    "difficulty_score": 3000,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M002",
    "title": "Two Pointers: 3Sum Closest Problem",
    "slug": "three-sum-closest",
    "difficulty": "Medium",
    "points": 3050,
    "topics": ["Two Pointers", "Array Manipulation", "Sorting"],
    "tags": ["two-pointers", "three-sum", "closest-sum", "optimization"],
    "statement_markdown": "Master **three-element sum optimization**:\n\n1. **Sum Minimization**: Find triplet with sum closest to target\n2. **Two Pointer Technique**: Efficient pair searching after fixing one element\n3. **Distance Optimization**: Track minimum absolute difference\n4. **Duplicate Handling**: Avoid redundant computations\n5. **Early Termination**: Optimize with exact match detection\n\nImplement efficient closest sum finding algorithms.",
    "input_format": "Integer array, target sum, optimization parameters",
    "output_format": "Closest sum value, contributing triplet, difference analysis",
    "constraints": [
      "3 <= n <= 1000 (array length)",
      "-1000 <= nums[i] <= 1000",
      "-10^4 <= target <= 10^4",
      "Array may contain duplicates",
      "Unique closest sum guaranteed"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[-1,2,1,-4], 1], "output": 2, "type": "public"},
      {"input": [[0,0,0], 1], "output": 0, "type": "public"},
      {"input": [[1,1,1,0], -100], "output": 2, "type": "hidden"},
      {"input": [[-1,0,1,2,-1,-4], 0], "output": 0, "type": "hidden"},
      {"input": [[1,1,-1,-1,3], -1], "output": -1, "type": "edge"},
      {"input": [[0,1,2], 3], "output": 3, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def threeSumClosest(nums, target):\n    nums.sort()\n    closest_sum = float('inf')\n    for i in range(len(nums) - 2):\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            if abs(current_sum - target) < abs(closest_sum - target):\n                closest_sum = current_sum\n            if current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return closest_sum",
        "time_complexity": "O(nÂ²)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "Sort the array first, then for each element, use two pointers to find the closest sum. Track the minimum difference encountered.",
    "hints": [
      "Sort the array to enable two-pointer technique",
      "Fix one element and use two pointers for the other two",
      "Track the closest sum seen so far"
    ],
    "difficulty_score": 3050,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M003",
    "title": "Sliding Window: Minimum Window Substring",
    "slug": "minimum-window-substring",
    "difficulty": "Medium",
    "points": 3100,
    "topics": ["Sliding Window", "Hash Map", "String Processing"],
    "tags": ["sliding-window", "substring", "hash-map", "character-frequency"],
    "statement_markdown": "Master **minimum window substring search**:\n\n1. **Window Management**: Expand and contract substring windows\n2. **Character Frequency**: Track required vs available characters\n3. **Valid Window Detection**: Identify when all requirements met\n4. **Optimization**: Find minimum valid window\n5. **Edge Case Handling**: Handle empty strings and impossible cases\n\nImplement efficient substring search with character constraints.",
    "input_format": "Source string, target pattern, character requirements",
    "output_format": "Minimum window substring or empty string if none exists",
    "constraints": [
      "1 <= s.length <= 10^5",
      "1 <= t.length <= 10^4",
      "s and t consist of uppercase and lowercase English letters",
      "Characters may repeat in pattern",
      "Case sensitive matching"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def minWindow(s, t):\n    from collections import Counter\n    required = Counter(t)\n    formed = 0\n    window_counts = {}\n    l, r = 0, 0\n    ans = float('inf'), None, None\n    \n    while r < len(s):\n        char = s[r]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in required and window_counts[char] == required[char]:\n            formed += 1\n        \n        while l <= r and formed == len(required):\n            if r - l + 1 < ans[0]:\n                ans = (r - l + 1, l, r)\n            char = s[l]\n            window_counts[char] -= 1\n            if char in required and window_counts[char] < required[char]:\n                formed -= 1\n            l += 1\n        r += 1\n    \n    return '' if ans[0] == float('inf') else s[ans[1]:ans[2] + 1]",
        "time_complexity": "O(|s| + |t|)",
        "space_complexity": "O(|s| + |t|)"
      }
    },
    "editorial": "Use two pointers to maintain a sliding window. Expand until all characters are covered, then contract to find the minimum valid window.",
    "hints": [
      "Use hash maps to track character frequencies",
      "Expand window until valid, then try to contract",
      "Keep track of the minimum valid window found"
    ],
    "difficulty_score": 3100,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M004",
    "title": "Graph Traversal: Number of Islands",
    "slug": "number-of-islands",
    "difficulty": "Medium",
    "points": 3150,
    "topics": ["Graph Traversal", "DFS", "BFS", "Connected Components"],
    "tags": ["dfs", "bfs", "grid", "connected-components", "island-counting"],
    "statement_markdown": "Master **connected component analysis**:\n\n1. **Grid Traversal**: Navigate 2D grid efficiently\n2. **DFS/BFS Implementation**: Explore connected land cells\n3. **Visited Tracking**: Mark explored cells to avoid cycles\n4. **Component Counting**: Count distinct connected regions\n5. **Boundary Handling**: Manage grid edges and invalid positions\n\nImplement efficient island counting in binary grids.",
    "input_format": "2D binary grid, traversal parameters, counting requirements",
    "output_format": "Number of distinct islands, island details, traversal analysis",
    "constraints": [
      "1 <= m, n <= 300 (grid dimensions)",
      "grid[i][j] is '0' (water) or '1' (land)",
      "Islands connected horizontally/vertically only",
      "Diagonal connections don't count",
      "Grid may be empty or all water"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def numIslands(grid):\n    if not grid or not grid[0]:\n        return 0\n    \n    def dfs(i, j):\n        if (i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or \n            grid[i][j] != '1'):\n            return\n        grid[i][j] = '0'  # Mark as visited\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n    \n    islands = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                dfs(i, j)\n                islands += 1\n    return islands",
        "time_complexity": "O(m Ã n)",
        "space_complexity": "O(m Ã n)"
      }
    },
    "editorial": "For each unvisited land cell, perform DFS/BFS to mark all connected land cells as visited, then increment island count. Continue until all cells processed.",
    "hints": [
      "Use DFS or BFS to explore connected components",
      "Mark visited cells to avoid counting them again",
      "Count the number of separate traversals needed"
    ],
    "difficulty_score": 3150,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M005",
    "title": "Dynamic Programming: Longest Increasing Subsequence",
    "slug": "longest-increasing-subsequence",
    "difficulty": "Medium",
    "points": 3200,
    "topics": ["Dynamic Programming", "Binary Search", "Sequence Analysis"],
    "tags": ["dynamic-programming", "lis", "binary-search", "subsequence"],
    "statement_markdown": "Master **longest increasing subsequence**:\n\n1. **DP State Design**: Define optimal substructure for LIS\n2. **Binary Search Optimization**: Reduce complexity from O(nÂ²) to O(n log n)\n3. **Patience Sorting**: Use tails array for efficient computation\n4. **Reconstruction**: Build actual LIS sequence if needed\n5. **Variants**: Handle strictly vs non-strictly increasing\n\nImplement efficient algorithms for subsequence optimization.",
    "input_format": "Integer array, subsequence constraints, optimization requirements",
    "output_format": "LIS length, actual subsequence, algorithm analysis",
    "constraints": [
      "1 <= n <= 2500 (array length)",
      "-10^4 <= nums[i] <= 10^4",
      "Array may contain duplicates",
      "Strictly increasing subsequence required",
      "Multiple valid LIS may exist"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def lengthOfLIS(nums):\n    import bisect\n    tails = []\n    for num in nums:\n        pos = bisect.bisect_left(tails, num)\n        if pos == len(tails):\n            tails.append(num)\n        else:\n            tails[pos] = num\n    return len(tails)",
        "time_complexity": "O(n log n)",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use binary search with tails array where tails[i] represents the smallest ending element of all increasing subsequences of length i+1.",
    "hints": [
      "Consider DP where dp[i] = LIS length ending at position i",
      "Optimize with binary search using patience sorting",
      "Maintain array of smallest tail elements for each length"
    ],
    "difficulty_score": 3200,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M006",
    "title": "Heap Data Structure: Merge K Sorted Lists",
    "slug": "merge-k-sorted-lists",
    "difficulty": "Medium",
    "points": 3250,
    "topics": ["Heap", "Priority Queue", "Divide and Conquer", "Linked Lists"],
    "tags": ["heap", "priority-queue", "merge", "linked-list", "divide-conquer"],
    "statement_markdown": "Master **efficient multi-way merging**:\n\n1. **Priority Queue**: Use min-heap for efficient minimum extraction\n2. **Divide and Conquer**: Merge lists pairwise for optimal complexity\n3. **Linked List Manipulation**: Handle node connections and traversal\n4. **Memory Management**: Optimize space usage and avoid duplication\n5. **Edge Cases**: Handle empty lists and null inputs\n\nImplement efficient algorithms for merging multiple sorted sequences.",
    "input_format": "Array of sorted linked lists, merging strategy, optimization parameters",
    "output_format": "Single merged sorted list, complexity analysis, merge statistics",
    "constraints": [
      "0 <= k <= 10^4 (number of lists)",
      "0 <= lists[i].length <= 500",
      "-10^4 <= Node.val <= 10^4",
      "Lists are sorted in ascending order",
      "Total nodes <= 10^4"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "import heapq\n\ndef mergeKLists(lists):\n    heap = []\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst.val, i, lst))\n    \n    dummy = ListNode(0)\n    current = dummy\n    \n    while heap:\n        val, i, node = heapq.heappop(heap)\n        current.next = node\n        current = current.next\n        \n        if node.next:\n            heapq.heappush(heap, (node.next.val, i, node.next))\n    \n    return dummy.next",
        "time_complexity": "O(N log k)",
        "space_complexity": "O(k)"
      }
    },
    "editorial": "Use a min-heap to efficiently find the smallest element among k list heads. Alternative: divide-and-conquer merging for space optimization.",
    "hints": [
      "Use priority queue to track smallest available elements",
      "Consider divide-and-conquer for space efficiency",
      "Handle edge cases: empty lists, null inputs"
    ],
    "difficulty_score": 3250,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M007",
    "title": "Graph Algorithms: Course Schedule and Topological Sort",
    "slug": "course-schedule-topological-sort",
    "difficulty": "Medium",
    "points": 3300,
    "topics": ["Graph Theory", "Topological Sort", "Cycle Detection", "DFS"],
    "tags": ["topological-sort", "cycle-detection", "dfs", "graph", "prerequisites"],
    "statement_markdown": "Master **dependency resolution and cycle detection**:\n\n1. **Topological Sorting**: Order vertices in directed acyclic graph\n2. **Cycle Detection**: Identify circular dependencies using DFS\n3. **Graph Representation**: Build adjacency lists from prerequisites\n4. **DFS States**: Track visiting/visited states for cycle detection\n5. **Valid Scheduling**: Determine if all courses can be completed\n\nImplement robust algorithms for dependency analysis and scheduling.",
    "input_format": "Number of courses, prerequisite pairs, dependency constraints",
    "output_format": "Boolean feasibility, valid course order, cycle analysis",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= ai, bi < numCourses",
      "All prerequisite pairs are unique"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def canFinish(numCourses, prerequisites):\n    graph = [[] for _ in range(numCourses)]\n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n    \n    state = [0] * numCourses  # 0: white, 1: gray, 2: black\n    \n    def dfs(node):\n        if state[node] == 1:  # gray - cycle detected\n            return False\n        if state[node] == 2:  # black - already processed\n            return True\n        \n        state[node] = 1  # mark as gray\n        for neighbor in graph[node]:\n            if not dfs(neighbor):\n                return False\n        state[node] = 2  # mark as black\n        return True\n    \n    for i in range(numCourses):\n        if state[i] == 0 and not dfs(i):\n            return False\n    return True",
        "time_complexity": "O(V + E)",
        "space_complexity": "O(V + E)"
      }
    },
    "editorial": "Model as directed graph where edges represent prerequisites. Use DFS with three-coloring to detect cycles - if no cycles exist, all courses can be completed.",
    "hints": [
      "Model prerequisites as directed graph edges",
      "Use DFS with state tracking for cycle detection",
      "Three states: unvisited, visiting, visited"
    ],
    "difficulty_score": 3300,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M008",
    "title": "Trie Data Structure: Implement Prefix Tree",
    "slug": "implement-trie-prefix-tree",
    "difficulty": "Medium",
    "points": 3350,
    "topics": ["Trie", "String Processing", "Prefix Search", "Data Structure Design"],
    "tags": ["trie", "prefix-tree", "string-search", "autocomplete", "data-structure"],
    "statement_markdown": "Master **trie data structure implementation**:\n\n1. **Node Structure**: Design efficient trie nodes with character mapping\n2. **Insert Operation**: Add words to trie with proper termination marking\n3. **Search Operation**: Check word existence with complete match validation\n4. **Prefix Search**: Implement efficient prefix matching\n5. **Memory Optimization**: Use array vs hashmap for character storage\n\nImplement complete trie functionality for string processing applications.",
    "input_format": "Trie operations (insert, search, startsWith), word lists, query patterns",
    "output_format": "Operation results, trie structure analysis, performance metrics",
    "constraints": [
      "1 <= word.length, prefix.length <= 2000",
      "word and prefix consist only of lowercase English letters",
      "At most 3 * 10^4 calls total to insert, search, and startsWith",
      "Words may have common prefixes",
      "Case-sensitive operations"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isEndOfWord = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEndOfWord = True\n    \n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.isEndOfWord\n    \n    def startsWith(self, prefix):\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True",
        "time_complexity": "O(m) per operation",
        "space_complexity": "O(ALPHABET_SIZE * N * M)"
      }
    },
    "editorial": "Trie stores strings character by character in a tree structure. Each path from root to leaf represents a word, with end-of-word flags marking valid terminations.",
    "hints": [
      "Use tree structure where each node represents a character",
      "Mark nodes to indicate end of valid words",
      "Traverse character by character for all operations"
    ],
    "difficulty_score": 3350,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M009",
    "title": "Backtracking: Combination Sum Variants",
    "slug": "combination-sum-variants",
    "difficulty": "Medium",
    "points": 3400,
    "topics": ["Backtracking", "Recursion", "Combinatorics", "Dynamic Programming"],
    "tags": ["backtracking", "combination-sum", "recursion", "pruning", "optimization"],
    "statement_markdown": "Master **combinatorial search with backtracking**:\n\n1. **Recursive Exploration**: Generate all valid combinations systematically\n2. **Pruning Strategies**: Eliminate invalid branches early\n3. **Duplicate Handling**: Manage repeated elements and unique solutions\n4. **Target Optimization**: Efficiently search for target sums\n5. **Memory Management**: Optimize space usage in recursive calls\n\nImplement efficient backtracking algorithms for combination problems.",
    "input_format": "Candidate array, target sum, combination constraints, uniqueness requirements",
    "output_format": "All valid combinations, search tree analysis, optimization metrics",
    "constraints": [
      "1 <= candidates.length <= 30",
      "2 <= candidates[i] <= 40",
      "All elements distinct (variant 1) or may contain duplicates (variant 2)",
      "1 <= target <= 40",
      "Each element can be used unlimited times (variant 1) or once (variant 2)"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def combinationSum(candidates, target):\n    result = []\n    \n    def backtrack(start, current, remaining):\n        if remaining == 0:\n            result.append(current[:])\n            return\n        if remaining < 0:\n            return\n        \n        for i in range(start, len(candidates)):\n            current.append(candidates[i])\n            backtrack(i, current, remaining - candidates[i])\n            current.pop()\n    \n    backtrack(0, [], target)\n    return result",
        "time_complexity": "O(N^(T/M))",
        "space_complexity": "O(T/M)"
      }
    },
    "editorial": "Use backtracking with careful index management to generate all valid combinations. Start index prevents duplicate permutations while recursion explores all possibilities.",
    "hints": [
      "Use backtracking to explore all possible combinations",
      "Maintain start index to avoid duplicate permutations",
      "Prune branches early when target becomes negative"
    ],
    "difficulty_score": 3400,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M010",
    "title": "Union-Find: Accounts Merge Problem",
    "slug": "accounts-merge-union-find",
    "difficulty": "Medium",
    "points": 3450,
    "topics": ["Union-Find", "Disjoint Set", "Graph Theory", "String Processing"],
    "tags": ["union-find", "disjoint-set", "merge", "connected-components", "email-grouping"],
    "statement_markdown": "Master **disjoint set union for entity merging**:\n\n1. **Union-Find Structure**: Implement efficient disjoint set operations\n2. **Path Compression**: Optimize find operations for near-constant time\n3. **Union by Rank**: Balance tree height for efficient merging\n4. **Connected Components**: Group related entities using shared properties\n5. **Result Construction**: Extract and format merged groups\n\nImplement robust algorithms for entity deduplication and grouping.",
    "input_format": "Account list with names and emails, merging criteria, output requirements",
    "output_format": "Merged account groups, union-find analysis, component statistics",
    "constraints": [
      "1 <= accounts.length <= 1000",
      "2 <= accounts[i].length <= 10",
      "1 <= accounts[i][j].length <= 30",
      "accounts[i][0] consists of English letters",
      "accounts[i][j] (for j > 0) is a valid email"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def accountsMerge(accounts):\n    parent = list(range(len(accounts)))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px != py:\n            parent[px] = py\n    \n    email_to_id = {}\n    for i, account in enumerate(accounts):\n        for email in account[1:]:\n            if email in email_to_id:\n                union(i, email_to_id[email])\n            else:\n                email_to_id[email] = i\n    \n    groups = {}\n    for i, account in enumerate(accounts):\n        root = find(i)\n        if root not in groups:\n            groups[root] = []\n        groups[root].extend(account[1:])\n    \n    result = []\n    for root, emails in groups.items():\n        result.append([accounts[root][0]] + sorted(set(emails)))\n    \n    return result",
        "time_complexity": "O(N * M * Î±(N))",
        "space_complexity": "O(N * M)"
      }
    },
    "editorial": "Map emails to account indices, then use Union-Find to group accounts sharing emails. Extract connected components and merge their email lists.",
    "hints": [
      "Map each email to its first occurrence account",
      "Use Union-Find to merge accounts with shared emails",
      "Group emails by connected component root"
    ],
    "difficulty_score": 3450,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M011",
    "title": "Greedy Algorithms: Gas Station Circuit",
    "slug": "gas-station-circuit",
    "difficulty": "Medium",
    "points": 3500,
    "topics": ["Greedy Algorithms", "Array Analysis", "Optimization"],
    "tags": ["greedy", "gas-station", "circuit", "optimization", "accumulation"],
    "statement_markdown": "Master **greedy optimization for circuit problems**:\n\n1. **Feasibility Check**: Determine if circuit completion is possible\n2. **Starting Point Selection**: Find optimal starting position\n3. **Greedy Strategy**: Use local decisions for global optimization\n4. **Accumulation Analysis**: Track running fuel balance\n5. **Circuit Traversal**: Handle circular array traversal\n\nImplement efficient algorithms for resource allocation and circuit optimization.",
    "input_format": "Gas amounts, fuel costs, station positions, circuit constraints",
    "output_format": "Starting station index or -1 if impossible, fuel analysis, traversal path",
    "constraints": [
      "1 <= gas.length == cost.length <= 10^4",
      "0 <= gas[i], cost[i] <= 10^4",
      "Solution guaranteed to be unique if exists",
      "Circular array traversal required",
      "Must complete full circuit"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def canCompleteCircuit(gas, cost):\n    total_tank = 0\n    current_tank = 0\n    start_station = 0\n    \n    for i in range(len(gas)):\n        total_tank += gas[i] - cost[i]\n        current_tank += gas[i] - cost[i]\n        \n        if current_tank < 0:\n            start_station = i + 1\n            current_tank = 0\n    \n    return start_station if total_tank >= 0 else -1",
        "time_complexity": "O(n)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "The greedy approach works because if you can't reach station j from station i, then you can't start from any station between i and j either. This allows us to skip intermediate starting points.",
    "hints": [
      "Check if total gas >= total cost for feasibility",
      "Use greedy strategy: when path fails, start from next station",
      "Track running fuel balance and deficit separately"
    ],
    "difficulty_score": 3500,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M012",
    "title": "Matrix Algorithms: Spiral Traversal",
    "slug": "spiral-matrix-traversal",
    "difficulty": "Medium",
    "points": 3550,
    "topics": ["Matrix Manipulation", "Array Traversal", "Boundary Management"],
    "tags": ["matrix", "spiral", "traversal", "boundary", "direction-control"],
    "statement_markdown": "Master **spiral matrix traversal patterns**:\n\n1. **Direction Control**: Manage traversal direction changes\n2. **Boundary Tracking**: Handle shrinking matrix boundaries\n3. **Spiral Pattern**: Implement clockwise/counterclockwise spirals\n4. **Edge Cases**: Handle single row/column and empty matrices\n5. **Index Management**: Prevent out-of-bounds access\n\nImplement robust algorithms for complex matrix traversal patterns.",
    "input_format": "2D matrix, traversal direction, boundary specifications",
    "output_format": "Spiral traversal sequence, boundary analysis, direction changes",
    "constraints": [
      "0 <= m, n <= 100 (matrix dimensions)",
      "m and n are non-negative",
      "-100 <= matrix[i][j] <= 100",
      "Matrix may be empty, single row, or single column",
      "Clockwise spiral traversal required"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def spiralOrder(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    \n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    \n    while top <= bottom and left <= right:\n        # Traverse right\n        for col in range(left, right + 1):\n            result.append(matrix[top][col])\n        top += 1\n        \n        # Traverse down\n        for row in range(top, bottom + 1):\n            result.append(matrix[row][right])\n        right -= 1\n        \n        # Traverse left (if still valid row)\n        if top <= bottom:\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n        \n        # Traverse up (if still valid column)\n        if left <= right:\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n    \n    return result",
        "time_complexity": "O(m Ã n)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "Maintain four boundary pointers and traverse in spiral order: rightâdownâleftâup. Shrink boundaries after each direction and check validity before traversing.",
    "hints": [
      "Use four boundary pointers: top, bottom, left, right",
      "Traverse in order: right, down, left, up",
      "Shrink boundaries after each direction"
    ],
    "difficulty_score": 3550,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M013",
    "title": "Bitmask Dynamic Programming: Subset Sum Optimization",
    "slug": "subset-sum-bitmask-dp",
    "difficulty": "Medium",
    "points": 3600,
    "topics": ["Bitmask DP", "Subset Enumeration", "Optimization", "Bit Manipulation"],
    "tags": ["bitmask-dp", "subset-sum", "bit-manipulation", "optimization", "enumeration"],
    "statement_markdown": "Master **bitmask dynamic programming**:\n\n1. **Bitmask Representation**: Use bits to represent subset states\n2. **Subset Enumeration**: Efficiently iterate through all subsets\n3. **DP State Compression**: Optimize space using bitwise operations\n4. **Transition Optimization**: Fast subset sum computation\n5. **Small N Optimization**: Leverage exponential algorithms for small inputs\n\nImplement efficient bitmask DP for subset problems with small constraints.",
    "input_format": "Integer array, target sum, subset constraints, optimization parameters",
    "output_format": "Subset existence, valid subsets, bitmask analysis, optimization metrics",
    "constraints": [
      "1 <= n <= 20 (small array size for bitmask)",
      "1 <= nums[i] <= 1000",
      "1 <= target <= 20000",
      "Array elements may be positive or negative",
      "Find all subsets or check existence"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def subsetSum(nums, target):\n    n = len(nums)\n    valid_subsets = []\n    \n    # Iterate through all possible subsets using bitmask\n    for mask in range(1 << n):\n        subset_sum = 0\n        subset = []\n        \n        # Check each bit in the mask\n        for i in range(n):\n            if mask & (1 << i):\n                subset_sum += nums[i]\n                subset.append(nums[i])\n        \n        if subset_sum == target:\n            valid_subsets.append(subset)\n    \n    return len(valid_subsets) > 0, valid_subsets",
        "time_complexity": "O(n Ã 2^n)",
        "space_complexity": "O(2^n)"
      }
    },
    "editorial": "Bitmask DP is optimal for small n where 2^n is manageable. Each bitmask represents a subset, and we check all possible combinations systematically.",
    "hints": [
      "Use bitmask to represent subset selection",
      "Iterate through all 2^n possible subsets",
      "Check each bit to determine element inclusion"
    ],
    "difficulty_score": 3600,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M014",
    "title": "Segment Tree: Range Sum Query with Updates",
    "slug": "range-sum-query-segment-tree",
    "difficulty": "Medium",
    "points": 3650,
    "topics": ["Segment Tree", "Range Queries", "Tree Data Structures", "Binary Tree"],
    "tags": ["segment-tree", "range-query", "range-update", "tree", "logarithmic"],
    "statement_markdown": "Master **segment tree for range operations**:\n\n1. **Tree Construction**: Build segment tree from array\n2. **Range Queries**: Efficiently query sum over ranges\n3. **Point Updates**: Update single elements with tree propagation\n4. **Lazy Propagation**: Optimize range updates (advanced)\n5. **Tree Traversal**: Navigate tree structure for operations\n\nImplement efficient data structures for dynamic range queries.",
    "input_format": "Initial array, query operations, update operations, range specifications",
    "output_format": "Query results, tree structure analysis, operation complexity metrics",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^5 <= nums[i] <= 10^5",
      "1 <= queries <= 10^4",
      "0 <= left <= right < nums.length",
      "Support both point updates and range queries"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "class NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.tree = [0] * (4 * self.n)\n        self._build(nums, 1, 0, self.n - 1)\n    \n    def _build(self, nums, node, start, end):\n        if start == end:\n            self.tree[node] = nums[start]\n        else:\n            mid = (start + end) // 2\n            self._build(nums, 2*node, start, mid)\n            self._build(nums, 2*node+1, mid+1, end)\n            self.tree[node] = self.tree[2*node] + self.tree[2*node+1]\n    \n    def update(self, index, val):\n        self._update(1, 0, self.n - 1, index, val)\n    \n    def _update(self, node, start, end, idx, val):\n        if start == end:\n            self.tree[node] = val\n        else:\n            mid = (start + end) // 2\n            if idx <= mid:\n                self._update(2*node, start, mid, idx, val)\n            else:\n                self._update(2*node+1, mid+1, end, idx, val)\n            self.tree[node] = self.tree[2*node] + self.tree[2*node+1]\n    \n    def sumRange(self, left, right):\n        return self._query(1, 0, self.n - 1, left, right)\n    \n    def _query(self, node, start, end, l, r):\n        if r < start or l > end:\n            return 0\n        if l <= start and end <= r:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return (self._query(2*node, start, mid, l, r) + \n                self._query(2*node+1, mid+1, end, l, r))",
        "time_complexity": "O(log n) per operation",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Segment tree stores aggregate information (sums) for ranges. Internal nodes represent range sums, with efficient updates through tree traversal and range queries through tree decomposition.",
    "hints": [
      "Build tree bottom-up with each node storing range sum",
      "Updates propagate from leaf to root",
      "Queries decompose ranges using tree structure"
    ],
    "difficulty_score": 3650,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M015",
    "title": "Hash Map Optimization: Subarray Sum Equals K",
    "slug": "subarray-sum-equals-k",
    "difficulty": "Medium",
    "points": 3700,
    "topics": ["Hash Map", "Prefix Sum", "Array Analysis", "Cumulative Sum"],
    "tags": ["hash-map", "prefix-sum", "subarray", "cumulative", "optimization"],
    "statement_markdown": "Master **prefix sum with hash map optimization**:\n\n1. **Prefix Sum Computation**: Calculate cumulative sums efficiently\n2. **Hash Map Lookup**: Use hash table for O(1) complement finding\n3. **Subarray Analysis**: Identify continuous subarrays with target sum\n4. **Frequency Tracking**: Count occurrences of prefix sums\n5. **Edge Case Handling**: Manage zero sums and negative numbers\n\nImplement efficient algorithms for subarray sum problems using hashing.",
    "input_format": "Integer array, target sum, counting requirements, optimization parameters",
    "output_format": "Count of valid subarrays, subarray details, prefix sum analysis",
    "constraints": [
      "1 <= nums.length <= 2 Ã 10^4",
      "-1000 <= nums[i] <= 1000",
      "-10^7 <= k <= 10^7",
      "Array may contain negative numbers and zeros",
      "Count all subarrays with sum equal to k"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def subarraySum(nums, k):\n    count = 0\n    prefix_sum = 0\n    sum_count = {0: 1}  # Empty prefix has sum 0\n    \n    for num in nums:\n        prefix_sum += num\n        \n        # Check if there exists a prefix sum such that\n        # current_prefix_sum - previous_prefix_sum = k\n        if prefix_sum - k in sum_count:\n            count += sum_count[prefix_sum - k]\n        \n        # Update frequency of current prefix sum\n        sum_count[prefix_sum] = sum_count.get(prefix_sum, 0) + 1\n    \n    return count",
        "time_complexity": "O(n)",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use prefix sums with hash map to track frequencies. For each position, check if (prefix_sum - k) exists, indicating a subarray with sum k ending at current position.",
    "hints": [
      "Use prefix sums to convert to two-sum problem",
      "Hash map stores frequency of each prefix sum seen",
      "For each position, look for complement prefix sum"
    ],
    "difficulty_score": 3700,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M016",
    "title": "Linked List Algorithms: Deep Copy with Random Pointer",
    "slug": "copy-list-with-random-pointer",
    "difficulty": "Medium",
    "points": 3750,
    "topics": ["Linked List", "Hash Map", "Deep Copy", "Pointer Manipulation"],
    "tags": ["linked-list", "deep-copy", "random-pointer", "hash-map", "pointer-algorithms"],
    "statement_markdown": "Master **deep copy of complex linked lists**:\n\n1. **Node Cloning**: Create new nodes for each original node\n2. **Random Pointer Assignment**: Correctly set random pointers in clone\n3. **Hash Map Mapping**: Use hash map to track original-to-clone mapping\n4. **Space Optimization**: Achieve O(1) space with in-place node weaving\n5. **Edge Case Handling**: Manage empty lists, cycles, and self-references\n\nImplement robust algorithms for deep copying linked lists with random pointers.",
    "input_format": "Linked list with next and random pointers, node values, pointer structure",
    "output_format": "Deep-copied linked list, pointer mapping analysis, clone verification",
    "constraints": [
      "0 <= n <= 10^5 (number of nodes)",
      "-10000 <= Node.val <= 10000",
      "Each node's random pointer may point to any node or null",
      "List may be empty or contain cycles",
      "Must return a deep copy (no shared nodes)"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "class Node:\n    def __init__(self, val, next=None, random=None):\n        self.val = val\n        self.next = next\n        self.random = random\n\ndef copyRandomList(head):\n    if not head:\n        return None\n    # Step 1: Clone nodes and interleave\n    curr = head\n    while curr:\n        new_node = Node(curr.val, curr.next, None)\n        curr.next = new_node\n        curr = new_node.next\n    # Step 2: Assign random pointers\n    curr = head\n    while curr:\n        if curr.random:\n            curr.next.random = curr.random.next\n        curr = curr.next.next\n    # Step 3: Separate lists\n    curr = head\n    pseudo_head = Node(0)\n    copy_curr = pseudo_head\n    while curr:\n        copy_curr.next = curr.next\n        curr.next = curr.next.next\n        curr = curr.next\n        copy_curr = copy_curr.next\n    return pseudo_head.next",
        "time_complexity": "O(n)",
        "space_complexity": "O(1) (in-place), O(n) (with hash map)"
      }
    },
    "editorial": "Hash map mapping is simplest for deep copy, but in-place node weaving achieves O(1) space. Interleave cloned nodes, assign random pointers, then separate lists.",
    "hints": [
      "Use hash map to map original nodes to clones",
      "For O(1) space, interleave cloned nodes with original",
      "Separate lists after pointer assignment"
    ],
    "difficulty_score": 3750,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M017",
    "title": "Graph Algorithms: Connected Components Analysis",
    "slug": "connected-components-undirected-graph",
    "difficulty": "Medium",
    "points": 3800,
    "topics": ["Graph Theory", "Union-Find", "DFS", "BFS", "Connected Components"],
    "tags": ["graph", "connected-components", "union-find", "dfs", "bfs"],
    "statement_markdown": "Master **connected component analysis in graphs**:\n\n1. **Graph Representation**: Use adjacency list/matrix for undirected graphs\n2. **Component Detection**: Identify all connected components\n3. **Union-Find Optimization**: Use disjoint set for efficient component tracking\n4. **Traversal Algorithms**: Apply DFS/BFS for component exploration\n5. **Component Properties**: Analyze size, structure, and connectivity\n\nImplement efficient algorithms for graph connectivity analysis.",
    "input_format": "Number of vertices, edge list, graph adjacency representation",
    "output_format": "Number of connected components, component details, connectivity analysis",
    "constraints": [
      "1 <= n <= 2000 (number of vertices)",
      "1 <= edges.length <= 5000",
      "edges[i].length == 2",
      "0 <= ai, bi < n",
      "ai != bi (no self-loops)",
      "No duplicate edges"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def countComponents(n, edges):\n    # Union-Find approach\n    parent = list(range(n))\n    rank = [0] * n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px == py:\n            return False\n        if rank[px] < rank[py]:\n            parent[px] = py\n        elif rank[px] > rank[py]:\n            parent[py] = px\n        else:\n            parent[py] = px\n            rank[px] += 1\n        return True\n    \n    components = n\n    for a, b in edges:\n        if union(a, b):\n            components -= 1\n    \n    return components",
        "time_complexity": "O(E Ã Î±(V))",
        "space_complexity": "O(V)"
      }
    },
    "editorial": "Use Union-Find for efficient component tracking or DFS/BFS for direct exploration. Each edge potentially merges two components, reducing total count.",
    "hints": [
      "Use DFS/BFS to explore each component fully",
      "Union-Find efficiently tracks component merging",
      "Count decreases when edges connect different components"
    ],
    "difficulty_score": 3800,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M018",
    "title": "Topological Sort: Alien Dictionary Character Ordering",
    "slug": "alien-dictionary-topological-sort",
    "difficulty": "Medium",
    "points": 3850,
    "topics": ["Topological Sort", "Graph Theory", "DFS", "Character Ordering"],
    "tags": ["topological-sort", "alien-dictionary", "graph", "character-ordering", "dfs"],
    "statement_markdown": "Master **topological sorting for character ordering**:\n\n1. **Dependency Graph Construction**: Build directed graph from word comparisons\n2. **Cycle Detection**: Identify invalid alien dictionaries\n3. **Topological Ordering**: Generate valid character sequence\n4. **DFS-based Algorithm**: Use post-order traversal for topological sort\n5. **Edge Case Handling**: Manage prefix relationships and invalid inputs\n\nImplement robust algorithms for constraint-based ordering problems.",
    "input_format": "Array of words in alien dictionary order, character relationships",
    "output_format": "Valid character ordering, dependency analysis, cycle detection results",
    "constraints": [
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 100",
      "words[i] consists of lowercase English letters only",
      "Valid alien dictionary may not exist",
      "Return any valid ordering if multiple exist"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def alienOrder(words):\n    # Build graph\n    graph = {}\n    in_degree = {}\n    \n    # Initialize graph\n    for word in words:\n        for char in word:\n            graph[char] = set()\n            in_degree[char] = 0\n    \n    # Add edges\n    for i in range(len(words) - 1):\n        word1, word2 = words[i], words[i + 1]\n        min_len = min(len(word1), len(word2))\n        \n        # Check for prefix violation\n        if len(word1) > len(word2) and word1[:min_len] == word2[:min_len]:\n            return \"\"\n        \n        for j in range(min_len):\n            if word1[j] != word2[j]:\n                if word2[j] not in graph[word1[j]]:\n                    graph[word1[j]].add(word2[j])\n                    in_degree[word2[j]] += 1\n                break\n    \n    # Topological sort using Kahn's algorithm\n    queue = [char for char in in_degree if in_degree[char] == 0]\n    result = []\n    \n    while queue:\n        char = queue.pop(0)\n        result.append(char)\n        for neighbor in graph[char]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return ''.join(result) if len(result) == len(in_degree) else \"\"",
        "time_complexity": "O(V + E)",
        "space_complexity": "O(V + E)"
      }
    },
    "editorial": "Extract character dependencies from adjacent word comparisons, build directed graph, then apply topological sort with cycle detection.",
    "hints": [
      "Compare adjacent words to find character dependencies",
      "Build directed graph from character ordering rules",
      "Use topological sort with cycle detection"
    ],
    "difficulty_score": 3850,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M019",
    "title": "Monotonic Stack: Next Greater Element Variants",
    "slug": "next-greater-element-monotonic-stack",
    "difficulty": "Medium",
    "points": 3900,
    "topics": ["Monotonic Stack", "Stack", "Array Analysis", "Optimization"],
    "tags": ["monotonic-stack", "next-greater", "stack", "optimization", "array-analysis"],
    "statement_markdown": "Master **monotonic stack for element comparison**:\n\n1. **Stack Monotonicity**: Maintain decreasing/increasing stack order\n2. **Next Greater Finding**: Efficiently find next larger elements\n3. **Circular Array Handling**: Manage wraparound comparisons\n4. **Stack Operations**: Optimize push/pop for linear time complexity\n5. **Variant Problems**: Solve previous greater, next smaller, etc.\n\nImplement efficient algorithms for comparative array analysis.",
    "input_format": "Integer array, comparison direction, circular array flag",
    "output_format": "Next greater elements array, stack operation analysis, comparison metrics",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^9",
      "Array may be circular or linear",
      "Handle duplicate elements correctly",
      "Return -1 if no greater element exists"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def nextGreaterElements(nums):\n    n = len(nums)\n    result = [-1] * n\n    stack = []\n    \n    # Process array twice for circular behavior\n    for i in range(2 * n):\n        # Pop elements smaller than current\n        while stack and nums[stack[-1]] < nums[i % n]:\n            idx = stack.pop()\n            result[idx] = nums[i % n]\n        \n        # Only push in first pass\n        if i < n:\n            stack.append(i)\n    \n    return result",
        "time_complexity": "O(n)",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Monotonic stack maintains decreasing order. When current element is larger, pop and assign as next greater. For circular arrays, process twice.",
    "hints": [
      "Use monotonic decreasing stack for next greater elements",
      "Pop smaller elements when current is larger",
      "For circular arrays, process array twice"
    ],
    "difficulty_score": 3900,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M020",
    "title": "Data Stream Analysis: Median Using Two Heaps",
    "slug": "data-stream-median-two-heaps",
    "difficulty": "Medium",
    "points": 3950,
    "topics": ["Heap", "Data Stream", "Median Finding", "Priority Queue"],
    "tags": ["heap", "data-stream", "median", "priority-queue", "two-heaps"],
    "statement_markdown": "Master **data stream median using two heaps**:\n\n1. **Heap Balancing**: Maintain balanced max-heap and min-heap\n2. **Median Calculation**: Efficiently compute median from heap tops\n3. **Dynamic Insertion**: Handle continuous data stream insertion\n4. **Heap Properties**: Manage heap size balance and ordering\n5. **Stream Processing**: Optimize for real-time median queries\n\nImplement efficient data structures for streaming median computation.",
    "input_format": "Stream of integers, insertion operations, median queries",
    "output_format": "Median values, heap state analysis, operation complexity metrics",
    "constraints": [
      "1 <= operations <= 5 Ã 10^4",
      "-10^5 <= num <= 10^5",
      "At most 50000 calls to addNum and findMedian",
      "findMedian will be called only after addNum",
      "Return median as double value"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.max_heap = []  # stores smaller half (negated for max behavior)\n        self.min_heap = []  # stores larger half\n    \n    def addNum(self, num):\n        # Add to appropriate heap\n        if not self.max_heap or num <= -self.max_heap[0]:\n            heapq.heappush(self.max_heap, -num)\n        else:\n            heapq.heappush(self.min_heap, num)\n        \n        # Rebalance heaps\n        if len(self.max_heap) > len(self.min_heap) + 1:\n            heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap))\n        elif len(self.min_heap) > len(self.max_heap) + 1:\n            heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))\n    \n    def findMedian(self):\n        if len(self.max_heap) == len(self.min_heap):\n            return (-self.max_heap[0] + self.min_heap[0]) / 2.0\n        elif len(self.max_heap) > len(self.min_heap):\n            return -self.max_heap[0]\n        else:\n            return self.min_heap[0]",
        "time_complexity": "O(log n) addNum, O(1) findMedian",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Two-heap approach maintains balanced heaps for efficient median computation. Max-heap stores smaller half, min-heap stores larger half.",
    "hints": [
      "Use max-heap for smaller half, min-heap for larger half",
      "Maintain balanced heap sizes (difference â¤ 1)",
      "Median is computed from heap tops in O(1) time"
    ],
    "difficulty_score": 3950,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M021",
    "title": "Binary Search: Rotated Sorted Array Search",
    "slug": "search-rotated-sorted-array",
    "difficulty": "Medium",
    "points": 4000,
    "topics": ["Binary Search", "Array Analysis", "Rotation Detection", "Logarithmic Search"],
    "tags": ["binary-search", "rotated-array", "sorted-array", "logarithmic", "pivot-detection"],
    "statement_markdown": "Master **binary search in rotated arrays**:\n\n1. **Rotation Detection**: Identify rotation point in sorted array\n2. **Binary Search Adaptation**: Modify search for rotated context\n3. **Pivot Finding**: Locate minimum element efficiently\n4. **Range Analysis**: Determine which half contains target\n5. **Edge Case Handling**: Manage duplicates and boundary conditions\n\nImplement efficient search algorithms for rotated sorted arrays.",
    "input_format": "Rotated sorted array, target value, search parameters",
    "output_format": "Target index or -1 if not found, search analysis, rotation point",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i] <= 10^4",
      "All values in nums are unique",
      "nums is rotated between 1 and n times",
      "-10^4 <= target <= 10^4"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        \n        # Check if left half is sorted\n        if nums[left] <= nums[mid]:\n            # Target is in the sorted left half\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            # Right half is sorted\n            # Target is in the sorted right half\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return -1",
        "time_complexity": "O(log n)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "Modified binary search for rotated arrays. Identify which half is sorted, check if target is in sorted range, then search appropriate half.",
    "hints": [
      "Identify which half of array is sorted",
      "Check if target is within sorted half range",
      "Use standard binary search logic with rotation awareness"
    ],
    "difficulty_score": 4000,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M022",
    "title": "Two Pointers: 3Sum Closest Optimization",
    "slug": "three-sum-closest",
    "difficulty": "Medium",
    "points": 4050,
    "topics": ["Two Pointers", "Sorting", "Array Analysis", "Optimization"],
    "tags": ["two-pointers", "3sum", "closest-sum", "sorting", "optimization"],
    "statement_markdown": "Master **two pointers for closest sum problems**:\n\n1. **Sorting Strategy**: Sort array to enable two-pointer technique\n2. **Closest Sum Tracking**: Maintain best approximation to target\n3. **Pointer Movement**: Optimize movement based on sum comparison\n4. **Distance Minimization**: Find triplet with minimum distance to target\n5. **Duplicate Handling**: Manage repeated values efficiently\n\nImplement efficient algorithms for closest sum optimization problems.",
    "input_format": "Integer array, target sum, optimization parameters",
    "output_format": "Closest sum to target, triplet analysis, distance calculations",
    "constraints": [
      "3 <= nums.length <= 500",
      "-1000 <= nums[i] <= 1000",
      "-10^4 <= target <= 10^4",
      "Array may contain duplicates",
      "Return the sum closest to target"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def threeSumClosest(nums, target):\n    nums.sort()\n    n = len(nums)\n    closest_sum = float('inf')\n    \n    for i in range(n - 2):\n        left, right = i + 1, n - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if abs(current_sum - target) < abs(closest_sum - target):\n                closest_sum = current_sum\n            \n            if current_sum < target:\n                left += 1\n            elif current_sum > target:\n                right -= 1\n            else:\n                return current_sum  # Exact match\n    \n    return closest_sum",
        "time_complexity": "O(nÂ²)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "Sort array and use two pointers for each fixed first element. Track closest sum by comparing distances to target.",
    "hints": [
      "Sort array to enable two-pointer technique",
      "For each first element, use two pointers for remaining pair",
      "Track closest sum by comparing absolute distances"
    ],
    "difficulty_score": 4050,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M023",
    "title": "Sliding Window: Minimum Window Substring",
    "slug": "minimum-window-substring",
    "difficulty": "Medium",
    "points": 4100,
    "topics": ["Sliding Window", "Hash Map", "String Processing", "Two Pointers"],
    "tags": ["sliding-window", "minimum-window", "substring", "hash-map", "string-matching"],
    "statement_markdown": "Master **sliding window for substring problems**:\n\n1. **Window Expansion**: Grow window until all characters included\n2. **Window Contraction**: Shrink window while maintaining validity\n3. **Character Frequency**: Track character counts with hash maps\n4. **Validity Checking**: Efficiently verify window contains all required chars\n5. **Minimum Tracking**: Maintain smallest valid window found\n\nImplement efficient algorithms for minimum window substring problems.",
    "input_format": "Source string, target pattern, character requirements",
    "output_format": "Minimum window substring, window analysis, character frequency tracking",
    "constraints": [
      "1 <= s.length, t.length <= 10^5",
      "s and t consist of uppercase and lowercase English letters",
      "It is guaranteed that answer is unique",
      "Return empty string if no valid window exists",
      "Case sensitive character matching"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def minWindow(s, t):\n    if not s or not t:\n        return \"\"\n    \n    dict_t = {}\n    for char in t:\n        dict_t[char] = dict_t.get(char, 0) + 1\n    \n    required = len(dict_t)\n    left, right = 0, 0\n    formed = 0\n    window_counts = {}\n    \n    ans = float(\"inf\"), None, None\n    \n    while right < len(s):\n        character = s[right]\n        window_counts[character] = window_counts.get(character, 0) + 1\n        \n        if character in dict_t and window_counts[character] == dict_t[character]:\n            formed += 1\n        \n        while left <= right and formed == required:\n            character = s[left]\n            \n            if right - left + 1 < ans[0]:\n                ans = (right - left + 1, left, right)\n            \n            window_counts[character] -= 1\n            if character in dict_t and window_counts[character] < dict_t[character]:\n                formed -= 1\n            \n            left += 1\n        \n        right += 1\n    \n    return \"\" if ans[0] == float(\"inf\") else s[ans[1]:ans[2] + 1]",
        "time_complexity": "O(|s| + |t|)",
        "space_complexity": "O(|s| + |t|)"
      }
    },
    "editorial": "Use sliding window with hash maps to track character frequencies. Expand window until valid, then contract while maintaining validity.",
    "hints": [
      "Use two pointers to define sliding window",
      "Track character frequencies with hash maps",
      "Expand window until valid, then contract optimally"
    ],
    "difficulty_score": 4100,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M024",
    "title": "Graph Traversal: Number of Islands in Grid",
    "slug": "number-of-islands-grid",
    "difficulty": "Medium",
    "points": 4150,
    "topics": ["DFS", "BFS", "Grid Traversal", "Connected Components", "Matrix"],
    "tags": ["dfs", "bfs", "islands", "grid", "connected-components"],
    "statement_markdown": "Master **grid traversal for connected components**:\n\n1. **Grid Representation**: Navigate 2D matrix with land/water cells\n2. **Island Detection**: Identify connected land regions\n3. **DFS/BFS Traversal**: Explore connected components systematically\n4. **Visited Tracking**: Mark explored cells to avoid cycles\n5. **Direction Vectors**: Handle 4-directional movement efficiently\n\nImplement efficient algorithms for grid-based connected component problems.",
    "input_format": "2D binary grid, land/water representation, traversal parameters",
    "output_format": "Number of islands, island details, traversal analysis",
    "constraints": [
      "1 <= grid.length <= 300",
      "1 <= grid[i].length <= 300",
      "grid[i][j] is '0' (water) or '1' (land)",
      "Islands are surrounded by water",
      "Connected horizontally or vertically (not diagonally)"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def numIslands(grid):\n    if not grid or not grid[0]:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    island_count = 0\n    \n    def dfs(r, c):\n        if (r < 0 or r >= rows or c < 0 or c >= cols or \n            grid[r][c] == '0'):\n            return\n        \n        grid[r][c] = '0'  # Mark as visited\n        \n        # Explore all 4 directions\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                island_count += 1\n                dfs(r, c)\n    \n    return island_count",
        "time_complexity": "O(m Ã n)",
        "space_complexity": "O(m Ã n)"
      }
    },
    "editorial": "Use DFS or BFS to explore connected land cells. Each unvisited land cell starts a new island traversal that marks all connected cells.",
    "hints": [
      "Use DFS/BFS to explore connected land cells",
      "Mark visited cells to avoid counting twice",
      "Each traversal from unvisited land represents one island"
    ],
    "difficulty_score": 4150,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M025",
    "title": "Dynamic Programming: Longest Increasing Subsequence",
    "slug": "longest-increasing-subsequence",
    "difficulty": "Medium",
    "points": 4200,
    "topics": ["Dynamic Programming", "Binary Search", "Sequence Analysis", "Optimization"],
    "tags": ["dynamic-programming", "lis", "binary-search", "subsequence", "optimization"],
    "statement_markdown": "Master **longest increasing subsequence optimization**:\n\n1. **DP State Definition**: Define optimal substructure for LIS\n2. **Transition Relations**: Build solutions from smaller subproblems\n3. **Binary Search Optimization**: Achieve O(n log n) complexity\n4. **Patience Sorting**: Use greedy approach with auxiliary array\n5. **Path Reconstruction**: Track actual subsequence if needed\n\nImplement efficient algorithms for sequence optimization problems.",
    "input_format": "Integer array, subsequence constraints, optimization parameters",
    "output_format": "LIS length, subsequence details, algorithm analysis",
    "constraints": [
      "1 <= nums.length <= 2500",
      "-10^4 <= nums[i] <= 10^4",
      "Return length of longest strictly increasing subsequence",
      "Subsequence maintains relative order",
      "Elements need not be contiguous"
    ],
    "time_limit_ms": 2000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def lengthOfLIS(nums):\n    import bisect\n    \n    aux = []\n    \n    for num in nums:\n        pos = bisect.bisect_left(aux, num)\n        \n        if pos == len(aux):\n            aux.append(num)\n        else:\n            aux[pos] = num\n    \n    return len(aux)",
        "time_complexity": "O(n log n)",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use binary search with auxiliary array for optimal solution. Maintain smallest tail element for each possible LIS length.",
    "hints": [
      "Consider DP approach: dp[i] = LIS length ending at i",
      "Optimize with binary search on auxiliary array",
      "Maintain smallest tail for each subsequence length"
    ],
    "difficulty_score": 4200,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M026",
    "title": "Heap Data Structure: Merge K Sorted Lists",
    "slug": "merge-k-sorted-lists",
    "difficulty": "Medium",
    "points": 4250,
    "topics": ["Heap", "Priority Queue", "Linked List", "Divide and Conquer"],
    "tags": ["heap", "priority-queue", "merge", "sorted-lists", "linked-list"],
    "statement_markdown": "Master **heap-based merging algorithms**:\n\n1. **Priority Queue Management**: Use min-heap for efficient minimum extraction\n2. **Multiple List Merging**: Merge k sorted lists simultaneously\n3. **Heap Operations**: Insert, extract-min, and heap maintenance\n4. **Divide and Conquer**: Alternative approach using pairwise merging\n5. **Memory Optimization**: Handle large datasets efficiently\n\nImplement efficient algorithms for merging multiple sorted sequences.",
    "input_format": "Array of k sorted linked lists, list specifications, merging parameters",
    "output_format": "Single merged sorted list, heap operation analysis, complexity metrics",
    "constraints": [
      "k == lists.length",
      "0 <= k <= 10^4",
      "0 <= lists[i].length <= 500",
      "-10^4 <= lists[i][j] <= 10^4",
      "lists[i] is sorted in ascending order",
      "Sum of lists[i].length <= 10^4"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "import heapq\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeKLists(lists):\n    heap = []\n    \n    # Initialize heap with first node from each list\n    for i, l in enumerate(lists):\n        if l:\n            heapq.heappush(heap, (l.val, i, l))\n    \n    dummy = ListNode(0)\n    current = dummy\n    \n    while heap:\n        val, i, node = heapq.heappop(heap)\n        current.next = node\n        current = current.next\n        \n        if node.next:\n            heapq.heappush(heap, (node.next.val, i, node.next))\n    \n    return dummy.next",
        "time_complexity": "O(N log k)",
        "space_complexity": "O(k)"
      }
    },
    "editorial": "Use min-heap to efficiently extract minimum from k sorted lists. Each extraction adds next element from same list, maintaining heap invariant.",
    "hints": [
      "Use min-heap to track minimum elements from all lists",
      "Extract minimum and add next element from same list",
      "Alternative: divide and conquer with pairwise merging"
    ],
    "difficulty_score": 4250,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M027",
    "title": "Graph Algorithms: Course Schedule and Topological Sort",
    "slug": "course-schedule-topological-sort",
    "difficulty": "Medium",
    "points": 4300,
    "topics": ["Graph", "Topological Sort", "DFS", "BFS", "Cycle Detection"],
    "tags": ["graph", "topological-sort", "dfs", "bfs", "cycle-detection", "prerequisites"],
    "statement_markdown": "Master **graph traversal and ordering algorithms**:\n\n1. **Topological Sorting**: Order vertices in directed acyclic graph (DAG)\n2. **Cycle Detection**: Identify circular dependencies in directed graphs\n3. **Prerequisite Management**: Model course dependencies and scheduling\n4. **DFS and BFS Approaches**: Multiple algorithms for topological ordering\n5. **Dependency Resolution**: Resolve complex prerequisite relationships\n\nImplement efficient algorithms for course scheduling and dependency management.",
    "input_format": "Number of courses, prerequisite pairs, scheduling parameters",
    "output_format": "Valid course order, cycle detection result, scheduling analysis",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= ai, bi < numCourses",
      "All pairs prerequisites[i] are unique"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "from collections import deque, defaultdict\n\ndef canFinish(numCourses, prerequisites):\n    # Build graph and in-degree count\n    graph = defaultdict(list)\n    in_degree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        in_degree[course] += 1\n    \n    # Kahn's algorithm\n    queue = deque([i for i in range(numCourses) if in_degree[i] == 0])\n    count = 0\n    \n    while queue:\n        course = queue.popleft()\n        count += 1\n        \n        for neighbor in graph[course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return count == numCourses\n\ndef findOrder(numCourses, prerequisites):\n    graph = defaultdict(list)\n    in_degree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        in_degree[course] += 1\n    \n    queue = deque([i for i in range(numCourses) if in_degree[i] == 0])\n    result = []\n    \n    while queue:\n        course = queue.popleft()\n        result.append(course)\n        \n        for neighbor in graph[course]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result if len(result) == numCourses else []",
        "time_complexity": "O(V + E)",
        "space_complexity": "O(V + E)"
      }
    },
    "editorial": "Model as directed graph with prerequisites as edges. Use topological sort (Kahn's algorithm or DFS) to find valid ordering. Detect cycles to determine feasibility.",
    "hints": [
      "Model as directed graph where edges represent prerequisites",
      "Use topological sort to find valid course ordering",
      "Detect cycles - if cycle exists, no valid schedule possible"
    ],
    "difficulty_score": 4300,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M028",
    "title": "Trie Data Structure: Design Add and Search Words Data Structure",
    "slug": "design-add-search-words-data-structure",
    "difficulty": "Medium",
    "points": 4350,
    "topics": ["Trie", "Design", "String", "DFS", "Backtracking"],
    "tags": ["trie", "prefix-tree", "design", "string-search", "wildcard", "dfs"],
    "statement_markdown": "Master **trie (prefix tree) data structure design**:\n\n1. **Trie Construction**: Build efficient prefix tree for string storage\n2. **Word Addition**: Insert strings with optimal space utilization\n3. **Wildcard Search**: Handle searches with '.' wildcard characters\n4. **DFS Traversal**: Navigate trie structure with recursive search\n5. **Memory Optimization**: Efficient storage for large dictionaries\n\nImplement a data structure supporting both exact and wildcard string searches.",
    "input_format": "Sequence of operations: addWord(word), search(word), operation parameters",
    "output_format": "Operation results, search success/failure, trie structure analysis",
    "constraints": [
      "1 <= word.length <= 25",
      "word in addWord consists of lowercase English letters",
      "word in search consist of '.' or lowercase English letters",
      "At most 2 * 10^4 calls to addWord and search"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def addWord(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n    \n    def search(self, word):\n        return self._search_helper(word, 0, self.root)\n    \n    def _search_helper(self, word, index, node):\n        if index == len(word):\n            return node.is_end_of_word\n        \n        char = word[index]\n        \n        if char == '.':\n            for child in node.children.values():\n                if self._search_helper(word, index + 1, child):\n                    return True\n            return False\n        else:\n            if char not in node.children:\n                return False\n            return self._search_helper(word, index + 1, node.children[char])",
        "time_complexity": "O(m) add, O(n) search worst case",
        "space_complexity": "O(total chars)"
      }
    },
    "editorial": "Use trie (prefix tree) for efficient string storage and retrieval. Handle wildcards with DFS, exploring all possible paths when encountering '.' character.",
    "hints": [
      "Build trie (prefix tree) with nodes containing children dictionary",
      "Use DFS for wildcard search - explore all paths for '.' character",
      "Mark end of words with boolean flag in nodes"
    ],
    "difficulty_score": 4350,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M029",
    "title": "Backtracking Algorithms: Combination Sum Variants",
    "slug": "combination-sum-variants",
    "difficulty": "Medium",
    "points": 4400,
    "topics": ["Backtracking", "Recursion", "Array", "Combinatorics"],
    "tags": ["backtracking", "recursion", "combination", "sum", "dfs", "pruning"],
    "statement_markdown": "Master **backtracking and combinatorial search algorithms**:\n\n1. **Recursive Exploration**: Build solutions incrementally with backtracking\n2. **Pruning Strategies**: Optimize search space with early termination\n3. **Combination Generation**: Find all valid combinations meeting criteria\n4. **State Management**: Track current path and remaining targets\n5. **Duplicate Handling**: Manage repeated elements and avoid duplicates\n\nImplement efficient backtracking algorithms for combination sum problems.",
    "input_format": "Array of candidates, target sum, combination parameters",
    "output_format": "All valid combinations, solution count, algorithm analysis",
    "constraints": [
      "1 <= candidates.length <= 30",
      "2 <= candidates[i] <= 40",
      "All elements of candidates are distinct",
      "1 <= target <= 40"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def combinationSum(candidates, target):\n    result = []\n    \n    def backtrack(start, combination, remaining):\n        if remaining == 0:\n            result.append(combination[:])\n            return\n        \n        if remaining < 0:\n            return\n        \n        for i in range(start, len(candidates)):\n            candidate = candidates[i]\n            \n            if candidate > remaining:\n                continue\n            \n            combination.append(candidate)\n            backtrack(i, combination, remaining - candidate)\n            combination.pop()\n    \n    backtrack(0, [], target)\n    return result",
        "time_complexity": "O(2^target)",
        "space_complexity": "O(target)"
      }
    },
    "editorial": "Use backtracking to explore all combinations. Start index prevents duplicates, pruning optimizes search when candidate exceeds remaining target.",
    "hints": [
      "Use backtracking to build combinations incrementally",
      "Maintain start index to avoid duplicate combinations",
      "Prune branches when candidate exceeds remaining target"
    ],
    "difficulty_score": 4400,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M030",
    "title": "Union-Find Data Structure: Accounts Merge",
    "slug": "accounts-merge",
    "difficulty": "Medium",
    "points": 4450,
    "topics": ["Union-Find", "Graph", "String", "Hash Table"],
    "tags": ["union-find", "disjoint-set", "graph", "merge", "email", "grouping"],
    "statement_markdown": "Master **Union-Find (Disjoint Set Union) data structure**:\n\n1. **Union-Find Operations**: Implement union, find, and path compression\n2. **Connected Components**: Group related elements efficiently\n3. **Email Association**: Merge accounts with common email addresses\n4. **Path Compression**: Optimize find operations for better performance\n5. **Union by Rank**: Balance trees to maintain efficiency\n\nImplement efficient algorithms for merging and grouping related data.",
    "input_format": "List of accounts with names and emails, merging parameters",
    "output_format": "Merged accounts grouped by connectivity, union-find analysis",
    "constraints": [
      "1 <= accounts.length <= 1000",
      "2 <= accounts[i].length <= 10",
      "1 <= accounts[i][j].length <= 30",
      "accounts[i][0] consists of English letters",
      "accounts[i][j] (for j > 0) is a valid email"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return\n        if self.rank[px] < self.rank[py]:\n            self.parent[px] = py\n        elif self.rank[px] > self.rank[py]:\n            self.parent[py] = px\n        else:\n            self.parent[py] = px\n            self.rank[px] += 1\n\ndef accountsMerge(accounts):\n    n = len(accounts)\n    uf = UnionFind(n)\n    \n    email_to_accounts = {}\n    for i, account in enumerate(accounts):\n        for email in account[1:]:\n            if email not in email_to_accounts:\n                email_to_accounts[email] = []\n            email_to_accounts[email].append(i)\n    \n    for email, account_indices in email_to_accounts.items():\n        for i in range(1, len(account_indices)):\n            uf.union(account_indices[0], account_indices[i])\n    \n    groups = {}\n    for i in range(n):\n        root = uf.find(i)\n        if root not in groups:\n            groups[root] = []\n        groups[root].append(i)\n    \n    result = []\n    for account_indices in groups.values():\n        emails = set()\n        name = accounts[account_indices[0]][0]\n        for idx in account_indices:\n            emails.update(accounts[idx][1:])\n        result.append([name] + sorted(emails))\n    \n    return result",
        "time_complexity": "O(n Ã Î±(n) + m)",
        "space_complexity": "O(n + m)"
      }
    },
    "editorial": "Use Union-Find to group accounts with shared emails. Map emails to accounts, union connected accounts, then collect sorted emails for each component.",
    "hints": [
      "Map each email to all accounts containing it",
      "Use Union-Find to group accounts with common emails",
      "Collect and sort emails for each connected component"
    ],
    "difficulty_score": 4450,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M031",
    "title": "Greedy Algorithms: Gas Station and Candy Distribution",
    "slug": "gas-station-candy-distribution",
    "difficulty": "Medium",
    "points": 4500,
    "topics": ["Greedy", "Array", "Simulation", "Optimization"],
    "tags": ["greedy", "gas-station", "candy", "circular-array", "optimization"],
    "statement_markdown": "Master **greedy optimization algorithms**:\n\n1. **Gas Station Problem**: Find starting position for circular journey\n2. **Candy Distribution**: Minimize candy allocation with constraints\n3. **Greedy Strategy**: Make locally optimal choices for global optimum\n4. **Circular Array**: Handle wraparound traversal efficiently\n5. **Constraint Satisfaction**: Meet neighboring requirements optimally\n\nImplement efficient greedy algorithms for resource optimization problems.",
    "input_format": "Gas stations with fuel/cost arrays, candy ratings, optimization parameters",
    "output_format": "Starting position, minimum candies, greedy solution analysis",
    "constraints": [
      "1 <= gas.length == cost.length <= 10^5",
      "0 <= gas[i], cost[i] <= 10^4",
      "1 <= ratings.length <= 2 * 10^4",
      "0 <= ratings[i] <= 2 * 10^4"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def canCompleteCircuit(gas, cost):\n    total_tank = 0\n    current_tank = 0\n    start_position = 0\n    \n    for i in range(len(gas)):\n        total_tank += gas[i] - cost[i]\n        current_tank += gas[i] - cost[i]\n        \n        if current_tank < 0:\n            start_position = i + 1\n            current_tank = 0\n    \n    return start_position if total_tank >= 0 else -1\n\ndef candy(ratings):\n    n = len(ratings)\n    candies = [1] * n\n    \n    # Left to right pass\n    for i in range(1, n):\n        if ratings[i] > ratings[i-1]:\n            candies[i] = candies[i-1] + 1\n    \n    # Right to left pass\n    for i in range(n-2, -1, -1):\n        if ratings[i] > ratings[i+1]:\n            candies[i] = max(candies[i], candies[i+1] + 1)\n    \n    return sum(candies)",
        "time_complexity": "O(n)",
        "space_complexity": "O(1) gas, O(n) candy"
      }
    },
    "editorial": "Use greedy strategy: gas station tracks deficit and resets start position; candy uses two passes to satisfy neighbor constraints with minimum allocation.",
    "hints": [
      "For gas station, if you can't reach from station i, try next station",
      "For candy, use two passes: left-to-right then right-to-left",
      "Track total deficit separately from current deficit"
    ],
    "difficulty_score": 4500,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M032",
    "title": "Matrix Algorithms: Spiral Matrix Traversal",
    "slug": "spiral-matrix-traversal",
    "difficulty": "Medium",
    "points": 4550,
    "topics": ["Matrix", "Simulation", "Array", "Two Pointers"],
    "tags": ["matrix", "spiral", "traversal", "simulation", "boundary"],
    "statement_markdown": "Master **matrix traversal and boundary management**:\n\n1. **Spiral Traversal**: Navigate matrix in clockwise spiral pattern\n2. **Boundary Management**: Track and update matrix boundaries dynamically\n3. **Direction Control**: Handle four directions with proper transitions\n4. **Edge Cases**: Handle single row, single column, and empty matrices\n5. **Space Optimization**: Achieve traversal with minimal extra space\n\nImplement efficient algorithms for matrix pattern traversal and manipulation.",
    "input_format": "2D matrix, traversal parameters, boundary specifications",
    "output_format": "Spiral order sequence, traversal path, algorithm analysis",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 10",
      "-100 <= matrix[i][j] <= 100"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def spiralOrder(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    \n    m, n = len(matrix), len(matrix[0])\n    result = []\n    \n    top, bottom = 0, m - 1\n    left, right = 0, n - 1\n    \n    while top <= bottom and left <= right:\n        # Traverse right\n        for col in range(left, right + 1):\n            result.append(matrix[top][col])\n        top += 1\n        \n        # Traverse down\n        for row in range(top, bottom + 1):\n            result.append(matrix[row][right])\n        right -= 1\n        \n        # Traverse left\n        if top <= bottom:\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n        \n        # Traverse up\n        if left <= right:\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n    \n    return result",
        "time_complexity": "O(m Ã n)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "Track four boundaries (top, bottom, left, right) and traverse in spiral order. Shrink boundaries after each direction and check validity before processing.",
    "hints": [
      "Use four boundaries: top, bottom, left, right",
      "Process directions: right â down â left â up",
      "Check boundary validity before processing left and up directions"
    ],
    "difficulty_score": 4550,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M033",
    "title": "Bitmask Dynamic Programming: Subset Sum with Small N",
    "slug": "subset-sum-bitmask-dp",
    "difficulty": "Medium",
    "points": 4600,
    "topics": ["Bitmask DP", "Dynamic Programming", "Bit Manipulation", "Subset"],
    "tags": ["bitmask", "dynamic-programming", "subset-sum", "bit-manipulation", "small-n"],
    "statement_markdown": "Master **bitmask dynamic programming techniques**:\n\n1. **Bitmask Representation**: Use bits to represent subset selections\n2. **State Compression**: Encode multiple boolean variables in single integer\n3. **Subset Enumeration**: Iterate through all possible subset combinations\n4. **Transition Optimization**: Efficient state transitions using bit operations\n5. **Small N Optimization**: Leverage exponential algorithms for small inputs\n\nImplement efficient bitmask DP for subset-based optimization problems.",
    "input_format": "Array of numbers, target sum, bitmask constraints",
    "output_format": "Subset existence, optimal subset, bitmask DP analysis",
    "constraints": [
      "1 <= nums.length <= 20",
      "1 <= nums[i] <= 1000",
      "1 <= target <= 1000",
      "All elements are positive integers"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def canPartition(nums, target):\n    n = len(nums)\n    \n    # Check all possible subsets using bitmask\n    for mask in range(1, 1 << n):\n        subset_sum = 0\n        \n        for i in range(n):\n            if mask & (1 << i):\n                subset_sum += nums[i]\n        \n        if subset_sum == target:\n            return True\n    \n    return False\n\n# Alternative DP approach\ndef canPartitionDP(nums, target):\n    dp = [False] * (target + 1)\n    dp[0] = True\n    \n    for num in nums:\n        for j in range(target, num - 1, -1):\n            dp[j] = dp[j] or dp[j - num]\n    \n    return dp[target]",
        "time_complexity": "O(2^n) bitmask, O(nÃtarget) DP",
        "space_complexity": "O(1) bitmask, O(target) DP"
      }
    },
    "editorial": "For small n, use bitmask to enumerate all subsets and check target sum. Alternative: use standard DP for better complexity with larger constraints.",
    "hints": [
      "Use bitmask to represent subset selections",
      "Iterate through all 2^n possible subsets",
      "For each subset, calculate sum and check against target"
    ],
    "difficulty_score": 4600,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M034",
    "title": "Segment Tree: Range Sum Query with Updates",
    "slug": "range-sum-query-updates",
    "difficulty": "Medium",
    "points": 4650,
    "topics": ["Segment Tree", "Data Structure", "Range Query", "Tree"],
    "tags": ["segment-tree", "range-query", "range-update", "tree", "lazy-propagation"],
    "statement_markdown": "Master **segment tree data structure for range operations**:\n\n1. **Range Query**: Efficiently query sum over any range [l, r]\n2. **Point Update**: Update single element and maintain tree structure\n3. **Tree Construction**: Build segment tree from input array\n4. **Lazy Propagation**: Optimize range updates with delayed computation\n5. **Space Optimization**: Efficient memory usage for large arrays\n\nImplement efficient segment tree for dynamic range sum queries.",
    "input_format": "Array of numbers, query operations, update operations",
    "output_format": "Query results, update confirmations, tree structure analysis",
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-100 <= nums[i] <= 100",
      "0 <= left <= right < nums.length",
      "-100 <= val <= 100",
      "At most 3 * 10^4 calls to update and sumRange"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "class NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.tree = [0] * (4 * self.n)\n        self.build(nums, 1, 0, self.n - 1)\n    \n    def build(self, nums, node, start, end):\n        if start == end:\n            self.tree[node] = nums[start]\n        else:\n            mid = (start + end) // 2\n            self.build(nums, 2*node, start, mid)\n            self.build(nums, 2*node+1, mid+1, end)\n            self.tree[node] = self.tree[2*node] + self.tree[2*node+1]\n    \n    def update(self, index, val):\n        self._update(1, 0, self.n - 1, index, val)\n    \n    def _update(self, node, start, end, idx, val):\n        if start == end:\n            self.tree[node] = val\n        else:\n            mid = (start + end) // 2\n            if idx <= mid:\n                self._update(2*node, start, mid, idx, val)\n            else:\n                self._update(2*node+1, mid+1, end, idx, val)\n            self.tree[node] = self.tree[2*node] + self.tree[2*node+1]\n    \n    def sumRange(self, left, right):\n        return self._query(1, 0, self.n - 1, left, right)\n    \n    def _query(self, node, start, end, l, r):\n        if r < start or end < l:\n            return 0\n        if l <= start and end <= r:\n            return self.tree[node]\n        mid = (start + end) // 2\n        left_sum = self._query(2*node, start, mid, l, r)\n        right_sum = self._query(2*node+1, mid+1, end, l, r)\n        return left_sum + right_sum",
        "time_complexity": "O(log n) update/query",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Build segment tree with internal nodes storing range sums. Update propagates changes up to root, query combines relevant subtree sums.",
    "hints": [
      "Use segment tree with 4*n size for safety",
      "Build recursively: leaf nodes = array elements, internal nodes = sum of children",
      "Update and query both use O(log n) tree traversal"
    ],
    "difficulty_score": 4650,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M035",
    "title": "Hash Table Algorithms: Subarray Sum Equals K",
    "slug": "subarray-sum-equals-k",
    "difficulty": "Medium",
    "points": 4700,
    "topics": ["Hash Table", "Array", "Prefix Sum", "Counting"],
    "tags": ["hash-table", "subarray", "prefix-sum", "counting", "cumulative-sum"],
    "statement_markdown": "Master **hash table optimization for subarray problems**:\n\n1. **Prefix Sum Technique**: Use cumulative sums for efficient range calculations\n2. **Hash Table Lookup**: Store and retrieve prefix sums in O(1) time\n3. **Subarray Counting**: Count all subarrays meeting specific sum criteria\n4. **Two-Sum Extension**: Extend two-sum concept to subarray problems\n5. **Negative Numbers**: Handle arrays with negative values correctly\n\nImplement efficient algorithms for subarray sum problems using hashing.",
    "input_format": "Array of integers, target sum k, counting parameters",
    "output_format": "Count of valid subarrays, subarray details, algorithm analysis",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-1000 <= nums[i] <= 1000",
      "-10^7 <= k <= 10^7"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def subarraySum(nums, k):\n    prefix_sum_count = {0: 1}\n    cumulative_sum = 0\n    result = 0\n    \n    for num in nums:\n        cumulative_sum += num\n        \n        # Check if there's a prefix sum that makes current subarray sum = k\n        needed_sum = cumulative_sum - k\n        if needed_sum in prefix_sum_count:\n            result += prefix_sum_count[needed_sum]\n        \n        # Add current cumulative sum to hash table\n        prefix_sum_count[cumulative_sum] = prefix_sum_count.get(cumulative_sum, 0) + 1\n    \n    return result",
        "time_complexity": "O(n)",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use prefix sum with hash table to count subarrays. For each position, check if (cumulative_sum - k) exists in hash table - this indicates a valid subarray.",
    "hints": [
      "Use prefix sum technique: subarray sum = prefix[j] - prefix[i-1]",
      "Store prefix sum frequencies in hash table",
      "For target k, look for (current_sum - k) in hash table"
    ],
    "difficulty_score": 4700,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M036",
    "title": "Linked List Algorithms: Copy List with Random Pointer",
    "slug": "copy-list-random-pointer",
    "difficulty": "Medium",
    "points": 4750,
    "topics": ["Linked List", "Hash Table", "Deep Copy", "Graph"],
    "tags": ["linked-list", "deep-copy", "random-pointer", "hash-table", "graph-cloning"],
    "statement_markdown": "Master **linked list deep copying with complex references**:\n\n1. **Deep Copy**: Create independent copy of linked list structure\n2. **Random Pointers**: Handle arbitrary cross-references between nodes\n3. **Hash Table Mapping**: Map original nodes to copied nodes\n4. **In-place Techniques**: Optimize space usage with clever pointer manipulation\n5. **Graph Perspective**: Treat as graph cloning problem\n\nImplement efficient algorithms for complex linked list duplication.",
    "input_format": "Linked list with next and random pointers, copy parameters",
    "output_format": "Deep copied list, pointer mappings, algorithm analysis",
    "constraints": [
      "0 <= n <= 1000",
      "-10^4 <= Node.val <= 10^4",
      "Node.random is null or pointing to another node in the list"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n        self.random = None\n\ndef copyRandomList(head):\n    if not head:\n        return None\n    \n    # Create mapping from original to copy\n    old_to_new = {}\n    \n    # First pass: create all nodes\n    current = head\n    while current:\n        old_to_new[current] = ListNode(current.val)\n        current = current.next\n    \n    # Second pass: set next and random pointers\n    current = head\n    while current:\n        if current.next:\n            old_to_new[current].next = old_to_new[current.next]\n        if current.random:\n            old_to_new[current].random = old_to_new[current.random]\n        current = current.next\n    \n    return old_to_new[head]",
        "time_complexity": "O(n)",
        "space_complexity": "O(n) hash table, O(1) interweaving"
      }
    },
    "editorial": "Create deep copy using hash table mapping or interweaving technique. Hash table: map originalâcopy, then set pointers. Interweaving: insert copies, set random pointers, separate lists.",
    "hints": [
      "Use hash table to map original nodes to their copies",
      "Two passes: first create nodes, second set pointers",
      "Alternative: interweave copies with originals for O(1) space"
    ],
    "difficulty_score": 4750,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M037",
    "title": "Graph Theory: Connected Components in Undirected Graph",
    "slug": "connected-components-undirected-graph",
    "difficulty": "Medium",
    "points": 4800,
    "topics": ["Graph", "DFS", "BFS", "Union-Find", "Connected Components"],
    "tags": ["graph", "connected-components", "dfs", "bfs", "union-find", "counting"],
    "statement_markdown": "Master **graph connectivity analysis algorithms**:\n\n1. **Connected Components**: Identify separate connected regions in graph\n2. **DFS Traversal**: Use depth-first search for component exploration\n3. **BFS Alternative**: Breadth-first search for level-wise exploration\n4. **Union-Find Approach**: Disjoint set union for efficient component tracking\n5. **Graph Representation**: Handle adjacency lists and edge lists efficiently\n\nImplement efficient algorithms for graph connectivity analysis.",
    "input_format": "Number of nodes, edge list, graph parameters",
    "output_format": "Component count, component details, algorithm analysis",
    "constraints": [
      "1 <= n <= 2000",
      "1 <= edges.length <= 5000",
      "edges[i].length == 2",
      "0 <= ai <= bi < n",
      "ai != bi",
      "No duplicate edges"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def countComponents(n, edges):\n    # Build adjacency list\n    graph = [[] for _ in range(n)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    visited = [False] * n\n    components = 0\n    \n    def dfs(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n    \n    for i in range(n):\n        if not visited[i]:\n            components += 1\n            dfs(i)\n    \n    return components",
        "time_complexity": "O(V + E)",
        "space_complexity": "O(V + E)"
      }
    },
    "editorial": "Use DFS to find connected components: for each unvisited node, start DFS to explore entire component. Count of DFS calls equals component count.",
    "hints": [
      "Build adjacency list from edge list",
      "Use DFS or BFS to explore each component",
      "Count number of times you start a new traversal"
    ],
    "difficulty_score": 4800,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M038",
    "title": "Topological Sort: Alien Dictionary Order",
    "slug": "alien-dictionary-order",
    "difficulty": "Medium",
    "points": 4850,
    "topics": ["Topological Sort", "Graph", "String", "DFS"],
    "tags": ["topological-sort", "alien-dictionary", "graph", "dfs", "character-ordering"],
    "statement_markdown": "Master **topological sorting for character ordering**:\n\n1. **Character Dependencies**: Extract ordering constraints from word sequences\n2. **Graph Construction**: Build directed graph from character relationships\n3. **Topological Sort**: Find valid character ordering using DFS or Kahn's algorithm\n4. **Cycle Detection**: Identify impossible orderings due to contradictions\n5. **Lexicographic Analysis**: Handle partial ordering and ambiguous cases\n\nImplement efficient algorithms for alien language character ordering.",
    "input_format": "Array of words in alien dictionary order, character analysis",
    "output_format": "Character ordering, dependency graph, topological analysis",
    "constraints": [
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 20",
      "words[i] consists of only lowercase English letters"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def alienOrder(words):\n    graph = {}\n    in_degree = {}\n    \n    # Initialize all characters\n    for word in words:\n        for char in word:\n            graph[char] = []\n            in_degree[char] = 0\n    \n    # Build graph from adjacent word comparisons\n    for i in range(len(words) - 1):\n        word1, word2 = words[i], words[i + 1]\n        min_len = min(len(word1), len(word2))\n        \n        for j in range(min_len):\n            if word1[j] != word2[j]:\n                graph[word1[j]].append(word2[j])\n                in_degree[word2[j]] += 1\n                break\n        else:\n            # Invalid: longer word before its prefix\n            if len(word1) > len(word2):\n                return \"\"\n    \n    # Topological sort using Kahn's algorithm\n    queue = [char for char in in_degree if in_degree[char] == 0]\n    result = []\n    \n    while queue:\n        char = queue.pop(0)\n        result.append(char)\n        \n        for neighbor in graph[char]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return ''.join(result) if len(result) == len(graph) else \"\"",
        "time_complexity": "O(C)",
        "space_complexity": "O(V + E)"
      }
    },
    "editorial": "Compare adjacent words to extract character dependencies, build directed graph, then use topological sort to determine valid character ordering.",
    "hints": [
      "Compare adjacent words to find character relationships",
      "Build directed graph from character dependencies",
      "Use topological sort to find valid ordering"
    ],
    "difficulty_score": 4850,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M039",
    "title": "Monotonic Stack: Next Greater Element Variants",
    "slug": "next-greater-element-variants",
    "difficulty": "Medium",
    "points": 4900,
    "topics": ["Monotonic Stack", "Stack", "Array", "Hash Table"],
    "tags": ["monotonic-stack", "next-greater", "stack", "array", "circular"],
    "statement_markdown": "Master **monotonic stack techniques for element relationships**:\n\n1. **Next Greater Element**: Find next larger element for each array position\n2. **Monotonic Properties**: Maintain stack with specific ordering properties\n3. **Circular Arrays**: Handle wraparound cases efficiently\n4. **Stack Optimization**: Use stack to reduce time complexity from O(nÂ²) to O(n)\n5. **Multiple Variants**: Handle different problem variations systematically\n\nImplement efficient algorithms for next greater/smaller element problems.",
    "input_format": "Arrays of numbers, circular array indicators, query parameters",
    "output_format": "Next greater elements, algorithm trace, stack operations",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^9",
      "All integers in nums are unique (for some variants)"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def nextGreaterElements(nums):\n    n = len(nums)\n    result = [-1] * n\n    stack = []\n    \n    # Process from right to left\n    for i in range(n - 1, -1, -1):\n        # Pop elements <= current element\n        while stack and nums[stack[-1]] <= nums[i]:\n            stack.pop()\n        \n        # Next greater element\n        if stack:\n            result[i] = nums[stack[-1]]\n        \n        # Push current index\n        stack.append(i)\n    \n    return result\n\n# Circular variant\ndef nextGreaterElementsCircular(nums):\n    n = len(nums)\n    result = [-1] * n\n    stack = []\n    \n    for i in range(2 * n - 1, -1, -1):\n        while stack and nums[stack[-1]] <= nums[i % n]:\n            stack.pop()\n        \n        if i < n and stack:\n            result[i] = nums[stack[-1]]\n        \n        stack.append(i % n)\n    \n    return result",
        "time_complexity": "O(n)",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use monotonic decreasing stack: traverse right to left, maintain stack of indices in decreasing order of values. Top of stack gives next greater element.",
    "hints": [
      "Use monotonic stack to maintain decreasing order",
      "Process array from right to left",
      "For circular arrays, process twice with modular arithmetic"
    ],
    "difficulty_score": 4900,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M040",
    "title": "Heap Data Structures: Find Median from Data Stream",
    "slug": "find-median-data-stream",
    "difficulty": "Medium",
    "points": 4950,
    "topics": ["Heap", "Two Heaps", "Design", "Data Stream"],
    "tags": ["heap", "median", "data-stream", "two-heaps", "priority-queue"],
    "statement_markdown": "Master **two-heap technique for dynamic median calculation**:\n\n1. **Data Stream Processing**: Handle continuous data input efficiently\n2. **Two Heap Strategy**: Use max-heap and min-heap for median tracking\n3. **Heap Balancing**: Maintain size constraints for optimal median access\n4. **Dynamic Updates**: Add numbers while preserving median property\n5. **Real-time Queries**: Provide O(1) median retrieval\n\nImplement efficient data structure for streaming median calculation.",
    "input_format": "Stream of numbers, addNum and findMedian operations",
    "output_format": "Median values, heap states, operation analysis",
    "constraints": [
      "-10^5 <= num <= 10^5",
      "At most 5 * 10^4 calls to addNum and findMedian"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.max_heap = []  # smaller half (negated values)\n        self.min_heap = []  # larger half\n    \n    def addNum(self, num):\n        # Add to appropriate heap\n        if not self.max_heap or num <= -self.max_heap[0]:\n            heapq.heappush(self.max_heap, -num)\n        else:\n            heapq.heappush(self.min_heap, num)\n        \n        # Balance heaps to maintain size constraint\n        if len(self.max_heap) > len(self.min_heap) + 1:\n            val = -heapq.heappop(self.max_heap)\n            heapq.heappush(self.min_heap, val)\n        elif len(self.min_heap) > len(self.max_heap) + 1:\n            val = heapq.heappop(self.min_heap)\n            heapq.heappush(self.max_heap, -val)\n    \n    def findMedian(self):\n        if len(self.max_heap) == len(self.min_heap):\n            return (-self.max_heap[0] + self.min_heap[0]) / 2.0\n        elif len(self.max_heap) > len(self.min_heap):\n            return float(-self.max_heap[0])\n        else:\n            return float(self.min_heap[0])",
        "time_complexity": "O(log n) add, O(1) median",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use two heaps strategy: max-heap for smaller half, min-heap for larger half. Maintain balanced sizes and extract median from heap tops efficiently.",
    "hints": [
      "Use two heaps: max-heap for smaller numbers, min-heap for larger numbers",
      "Keep heap sizes balanced: difference â¤ 1",
      "Median is average of tops (even count) or top of larger heap (odd count)"
    ],
    "difficulty_score": 4950,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M041",
    "title": "Binary Search: Search in Rotated Sorted Array",
    "slug": "search-rotated-sorted-array",
    "difficulty": "Medium",
    "points": 5000,
    "topics": ["Binary Search", "Array", "Divide and Conquer"],
    "tags": ["binary-search", "rotated-array", "sorted-array", "search", "divide-conquer"],
    "statement_markdown": "Master **binary search in rotated sorted arrays**:\n\n1. **Rotation Analysis**: Identify pivot point and sorted halves\n2. **Modified Binary Search**: Adapt binary search for rotated context\n3. **Range Identification**: Determine which half contains target\n4. **Edge Case Handling**: Handle duplicates and single elements\n5. **Optimal Complexity**: Maintain O(log n) time complexity\n\nImplement efficient search algorithm for rotated sorted arrays.",
    "input_format": "Rotated sorted array and target value",
    "output_format": "Target index or -1 if not found, algorithm analysis",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i] <= 10^4",
      "All values of nums are unique",
      "-10^4 <= target <= 10^4"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        \n        # Left half is sorted\n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        # Right half is sorted\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return -1",
        "time_complexity": "O(log n)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "Use modified binary search: identify which half is sorted, check if target lies in sorted range, then search appropriate half maintaining O(log n) complexity.",
    "hints": [
      "At least one half of the array is always sorted",
      "Check which half is sorted using boundary comparison", 
      "Search the half that could contain the target"
    ],
    "difficulty_score": 5000,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M042",
    "title": "Two Pointers: 3Sum and 3Sum Closest",
    "slug": "three-sum-variants",
    "difficulty": "Medium",
    "points": 5050,
    "topics": ["Two Pointers", "Array", "Sorting"],
    "tags": ["two-pointers", "3sum", "sorting", "duplicates", "closest-sum"],
    "statement_markdown": "Master **two-pointer techniques for triplet problems**:\n\n1. **Triplet Sum**: Find all unique triplets that sum to target\n2. **Duplicate Handling**: Skip duplicate elements efficiently\n3. **Two-Pointer Optimization**: Reduce O(nÂ³) to O(nÂ²) complexity\n4. **Closest Sum**: Find triplet with sum closest to target\n5. **Sorting Strategy**: Use sorted array for efficient pointer movement\n\nImplement efficient algorithms for various 3Sum problem variants.",
    "input_format": "Array of integers, target sum for analysis",
    "output_format": "Triplets, closest sum, algorithm trace",
    "constraints": [
      "3 <= nums.length <= 3000",
      "-10^5 <= nums[i] <= 10^5",
      "-10^5 <= target <= 10^5"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def threeSum(nums):\n    nums.sort()\n    result = []\n    \n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        \n        left, right = i + 1, len(nums) - 1\n        \n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            \n            if total == 0:\n                result.append([nums[i], nums[left], nums[right]])\n                \n                while left < right and nums[left] == nums[left+1]:\n                    left += 1\n                while left < right and nums[right] == nums[right-1]:\n                    right -= 1\n                \n                left += 1\n                right -= 1\n            elif total < 0:\n                left += 1\n            else:\n                right -= 1\n    \n    return result",
        "time_complexity": "O(nÂ²)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "Sort array, fix first element, use two pointers to find complementary pairs. Skip duplicates to ensure unique triplets while maintaining O(nÂ²) complexity.",
    "hints": [
      "Sort the array first to enable two-pointer technique",
      "Fix the first element and find two-sum for remaining target",
      "Skip duplicates to avoid redundant triplets"
    ],
    "difficulty_score": 5050,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M043",
    "title": "Sliding Window: Minimum Window Substring",
    "slug": "minimum-window-substring",
    "difficulty": "Medium",
    "points": 5100,
    "topics": ["Sliding Window", "Hash Table", "String", "Two Pointers"],
    "tags": ["sliding-window", "minimum-window", "substring", "hash-table", "two-pointers"],
    "statement_markdown": "Master **sliding window for substring problems**:\n\n1. **Variable Window**: Expand and contract window dynamically\n2. **Character Frequency**: Track required vs current character counts\n3. **Validity Checking**: Determine when window contains all required characters\n4. **Window Optimization**: Minimize window size while maintaining validity\n5. **Efficient Tracking**: Use hash maps for O(1) character operations\n\nImplement efficient algorithm for minimum window substring problem.",
    "input_format": "Source string and target pattern string",
    "output_format": "Minimum window substring, window analysis, algorithm trace",
    "constraints": [
      "1 <= s.length, t.length <= 10^5",
      "s and t consist of uppercase and lowercase English letters"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def minWindow(s, t):\n    if not s or not t:\n        return \"\"\n    \n    target_freq = {}\n    for char in t:\n        target_freq[char] = target_freq.get(char, 0) + 1\n    \n    required = len(target_freq)\n    formed = 0\n    window_freq = {}\n    \n    left = right = 0\n    ans = float('inf'), None, None\n    \n    while right < len(s):\n        char = s[right]\n        window_freq[char] = window_freq.get(char, 0) + 1\n        \n        if char in target_freq and window_freq[char] == target_freq[char]:\n            formed += 1\n        \n        while left <= right and formed == required:\n            char = s[left]\n            \n            if right - left + 1 < ans[0]:\n                ans = (right - left + 1, left, right)\n            \n            window_freq[char] -= 1\n            if char in target_freq and window_freq[char] < target_freq[char]:\n                formed -= 1\n            \n            left += 1\n        \n        right += 1\n    \n    return \"\" if ans[0] == float('inf') else s[ans[1]:ans[2] + 1]",
        "time_complexity": "O(|s| + |t|)",
        "space_complexity": "O(|s| + |t|)"
      }
    },
    "editorial": "Use sliding window with hash maps: expand window until valid (contains all target characters), then contract to find minimum valid window.",
    "hints": [
      "Use hash map to track character frequencies",
      "Expand window until it contains all required characters",
      "Contract window to minimize size while maintaining validity"
    ],
    "difficulty_score": 5100,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M044",
    "title": "Graph Traversal: Number of Islands in Grid",
    "slug": "number-of-islands",
    "difficulty": "Medium",
    "points": 5150,
    "topics": ["DFS", "BFS", "Matrix", "Graph", "Union Find"],
    "tags": ["dfs", "bfs", "islands", "grid", "connected-components", "union-find"],
    "statement_markdown": "Master **graph traversal in 2D grids**:\n\n1. **Island Detection**: Identify connected land components in grid\n2. **DFS Traversal**: Recursive exploration of connected cells\n3. **BFS Alternative**: Level-order traversal using queue\n4. **Grid Navigation**: Handle 4-directional movement efficiently\n5. **Visited Tracking**: Avoid revisiting cells during traversal\n\nImplement multiple algorithms for counting connected components in 2D grid.",
    "input_format": "2D binary grid where 1=land, 0=water",
    "output_format": "Number of islands, traversal analysis, algorithm comparison",
    "constraints": [
      "1 <= grid.length, grid[i].length <= 300",
      "grid[i][j] is '0' or '1'"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def numIslands(grid):\n    if not grid or not grid[0]:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    islands = 0\n    \n    def dfs(r, c):\n        if (r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != '1'):\n            return\n        \n        grid[r][c] = '0'  # Mark as visited\n        \n        # Explore 4 directions\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                islands += 1\n                dfs(r, c)\n    \n    return islands",
        "time_complexity": "O(m Ã n)",
        "space_complexity": "O(min(m, n))"
      }
    },
    "editorial": "Use DFS or BFS to find connected components. For each unvisited land cell, increment island count and traverse entire connected component to mark as visited.",
    "hints": [
      "Treat each land cell as a graph node connected to adjacent land cells",
      "Use DFS or BFS to traverse each connected component",
      "Count the number of connected components"
    ],
    "difficulty_score": 5150,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M045",
    "title": "Dynamic Programming: Longest Increasing Subsequence",
    "slug": "longest-increasing-subsequence",
    "difficulty": "Medium",
    "points": 5200,
    "topics": ["Dynamic Programming", "Binary Search", "Array"],
    "tags": ["dp", "lis", "binary-search", "subsequence", "optimization"],
    "statement_markdown": "Master **dynamic programming for sequence optimization**:\n\n1. **Subsequence Analysis**: Find longest strictly increasing subsequence\n2. **DP State Design**: Define optimal substructure for LIS problem\n3. **Multiple Approaches**: O(nÂ²) DP and O(n log n) binary search optimization\n4. **Patience Sorting**: Advanced technique using binary search\n5. **Reconstruction**: Track actual LIS sequence, not just length\n\nImplement efficient algorithms for longest increasing subsequence variants.",
    "input_format": "Array of integers for subsequence analysis",
    "output_format": "LIS length, actual sequence, algorithm comparison",
    "constraints": [
      "1 <= nums.length <= 2500",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def lengthOfLIS(nums):\n    if not nums:\n        return 0\n    \n    tails = []\n    \n    for num in nums:\n        left, right = 0, len(tails)\n        \n        # Binary search for position\n        while left < right:\n            mid = (left + right) // 2\n            if tails[mid] < num:\n                left = mid + 1\n            else:\n                right = mid\n        \n        # Insert or replace\n        if left == len(tails):\n            tails.append(num)\n        else:\n            tails[left] = num\n    \n    return len(tails)",
        "time_complexity": "O(n log n)",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use patience sorting with binary search: maintain array of smallest tail elements for each LIS length. For each element, find position using binary search and extend or update.",
    "hints": [
      "Consider DP approach: dp[i] = LIS length ending at position i",
      "Optimize with binary search: maintain smallest tail for each length",
      "Use patience sorting technique for O(n log n) solution"
    ],
    "difficulty_score": 5200,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M046",
    "title": "Priority Queue: Merge k Sorted Lists",
    "slug": "merge-k-sorted-lists",
    "difficulty": "Medium",
    "points": 5250,
    "topics": ["Heap", "Linked List", "Divide and Conquer", "Priority Queue"],
    "tags": ["heap", "priority-queue", "merge", "sorted-lists", "divide-conquer"],
    "statement_markdown": "Master **heap-based merging algorithms**:\n\n1. **Multiple Sorted Lists**: Efficiently merge k sorted linked lists\n2. **Priority Queue Strategy**: Use min-heap to track smallest elements\n3. **Divide and Conquer**: Alternative approach with pairwise merging\n4. **Memory Optimization**: In-place merging techniques\n5. **Complexity Analysis**: Compare different merging strategies\n\nImplement efficient algorithms for merging multiple sorted data structures.",
    "input_format": "Array of k sorted linked lists",
    "output_format": "Single merged sorted list, algorithm analysis",
    "constraints": [
      "k == lists.length",
      "0 <= k <= 10^4",
      "0 <= lists[i].length <= 500",
      "-10^4 <= lists[i][j] <= 10^4",
      "lists[i] is sorted in ascending order"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "import heapq\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeKLists(lists):\n    heap = []\n    \n    # Initialize heap with first node from each non-empty list\n    for i, head in enumerate(lists):\n        if head:\n            heapq.heappush(heap, (head.val, i, head))\n    \n    dummy = ListNode(0)\n    current = dummy\n    \n    while heap:\n        val, list_idx, node = heapq.heappop(heap)\n        \n        # Add node to result\n        current.next = node\n        current = current.next\n        \n        # Add next node from same list if exists\n        if node.next:\n            heapq.heappush(heap, (node.next.val, list_idx, node.next))\n    \n    return dummy.next",
        "time_complexity": "O(N log k)",
        "space_complexity": "O(k)"
      }
    },
    "editorial": "Use min-heap to efficiently track smallest unprocessed element from each list. Extract minimum, add to result, and insert next element from same list maintaining O(N log k) complexity.",
    "hints": [
      "Use priority queue (min-heap) to track smallest elements",
      "Extract minimum element and add next from same list",
      "Consider divide-and-conquer as alternative approach"
    ],
    "difficulty_score": 5250,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M047",
    "title": "Graph Theory: Course Schedule and Cycle Detection",
    "slug": "course-schedule-cycle-detection",
    "difficulty": "Medium",
    "points": 5300,
    "topics": ["Graph", "Topological Sort", "DFS", "BFS", "Cycle Detection"],
    "tags": ["topological-sort", "cycle-detection", "course-schedule", "dfs", "bfs"],
    "statement_markdown": "Master **cycle detection and topological sorting**:\n\n1. **Dependency Modeling**: Represent prerequisites as directed graph\n2. **Cycle Detection**: Identify impossible scheduling due to circular dependencies\n3. **Topological Sort**: Find valid ordering of courses/tasks\n4. **Multiple Algorithms**: DFS-based and BFS-based (Kahn's) approaches\n5. **Course Ordering**: Generate specific valid course sequences\n\nImplement robust algorithms for dependency resolution and scheduling problems.",
    "input_format": "Number of courses and prerequisite pairs",
    "output_format": "Feasibility check, valid ordering, cycle analysis",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= ai, bi < numCourses",
      "All the pairs prerequisites[i] are unique"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def canFinish(numCourses, prerequisites):\n    # Build adjacency list and in-degree count\n    graph = [[] for _ in range(numCourses)]\n    in_degree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        in_degree[course] += 1\n    \n    # Kahn's algorithm\n    queue = []\n    for i in range(numCourses):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    processed = 0\n    \n    while queue:\n        course = queue.pop(0)\n        processed += 1\n        \n        for next_course in graph[course]:\n            in_degree[next_course] -= 1\n            if in_degree[next_course] == 0:\n                queue.append(next_course)\n    \n    return processed == numCourses\n\ndef findOrder(numCourses, prerequisites):\n    graph = [[] for _ in range(numCourses)]\n    in_degree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        in_degree[course] += 1\n    \n    queue = []\n    for i in range(numCourses):\n        if in_degree[i] == 0:\n            queue.append(i)\n    \n    result = []\n    \n    while queue:\n        course = queue.pop(0)\n        result.append(course)\n        \n        for next_course in graph[course]:\n            in_degree[next_course] -= 1\n            if in_degree[next_course] == 0:\n                queue.append(next_course)\n    \n    return result if len(result) == numCourses else []",
        "time_complexity": "O(V + E)",
        "space_complexity": "O(V + E)"
      }
    },
    "editorial": "Build directed graph from prerequisites. Use Kahn's algorithm with BFS to detect cycles and find topological ordering. If all courses processed, no cycle exists.",
    "hints": [
      "Model prerequisites as directed graph edges",
      "Use topological sort to detect cycles",
      "Kahn's algorithm: repeatedly remove nodes with no incoming edges"
    ],
    "difficulty_score": 5300,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M048",
    "title": "Trie Data Structure: Implement Word Dictionary",
    "slug": "implement-trie-word-dictionary",
    "difficulty": "Medium",
    "points": 5350,
    "topics": ["Trie", "Design", "String", "Hash Table"],
    "tags": ["trie", "prefix-tree", "word-dictionary", "design", "string-search"],
    "statement_markdown": "Master **Trie (Prefix Tree) data structure**:\n\n1. **Tree Construction**: Build efficient prefix tree for string storage\n2. **Word Operations**: Insert, search, and prefix matching\n3. **Wildcard Support**: Handle '.' as any character in search\n4. **Memory Optimization**: Efficient node representation and compression\n5. **Advanced Operations**: Auto-completion and pattern matching\n\nImplement complete Trie data structure with various search capabilities.",
    "input_format": "Sequence of insert, search, and startsWith operations",
    "output_format": "Operation results, trie structure analysis, complexity analysis",
    "constraints": [
      "1 <= word.length, prefix.length <= 2000",
      "word and prefix consist only of lowercase English letters",
      "At most 3 * 10^4 calls to insert, search, and startsWith"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        current = self.root\n        for char in word:\n            if char not in current.children:\n                current.children[char] = TrieNode()\n            current = current.children[char]\n        current.is_end_word = True\n    \n    def search(self, word):\n        current = self.root\n        for char in word:\n            if char not in current.children:\n                return False\n            current = current.children[char]\n        return current.is_end_word\n    \n    def startsWith(self, prefix):\n        current = self.root\n        for char in prefix:\n            if char not in current.children:\n                return False\n            current = current.children[char]\n        return True",
        "time_complexity": "O(m) per operation",
        "space_complexity": "O(ALPHABET_SIZE Ã N Ã M)"
      }
    },
    "editorial": "Build prefix tree where each node represents a character. Navigate tree for operations: insert adds path, search checks path + end flag, startsWith checks path existence.",
    "hints": [
      "Use tree structure where each node represents a character",
      "Mark end of words with boolean flag in nodes",
      "For wildcards, use DFS to explore all possible paths"
    ],
    "difficulty_score": 5350,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M049",
    "title": "Backtracking: Combination Sum Variants",
    "slug": "combination-sum-variants",
    "difficulty": "Medium",
    "points": 5400,
    "topics": ["Backtracking", "Array", "Recursion"],
    "tags": ["backtracking", "combination-sum", "recursion", "pruning", "duplicate-handling"],
    "statement_markdown": "Master **backtracking for combination problems**:\n\n1. **Combination Generation**: Find all combinations that sum to target\n2. **Duplicate Handling**: Manage arrays with duplicate elements\n3. **Backtracking Strategy**: Systematic exploration with pruning\n4. **Multiple Variants**: Unlimited use vs single use of elements\n5. **Optimization Techniques**: Early termination and sorting for efficiency\n\nImplement efficient backtracking algorithms for various combination sum problems.",
    "input_format": "Array of candidates and target sum",
    "output_format": "All valid combinations, algorithm analysis, pruning strategies",
    "constraints": [
      "1 <= candidates.length <= 30",
      "2 <= candidates[i] <= 40",
      "All elements of candidates are distinct",
      "1 <= target <= 40"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def combinationSum(candidates, target):\n    candidates.sort()\n    result = []\n    \n    def backtrack(start, current_combination, remaining_target):\n        if remaining_target == 0:\n            result.append(current_combination[:])\n            return\n        \n        for i in range(start, len(candidates)):\n            candidate = candidates[i]\n            \n            # Pruning: if current candidate > remaining, break\n            if candidate > remaining_target:\n                break\n            \n            # Choose\n            current_combination.append(candidate)\n            \n            # Recurse (can reuse same element)\n            backtrack(i, current_combination, remaining_target - candidate)\n            \n            # Backtrack\n            current_combination.pop()\n    \n    backtrack(0, [], target)\n    return result",
        "time_complexity": "O(N^(T/M))",
        "space_complexity": "O(T/M)"
      }
    },
    "editorial": "Use backtracking with pruning: sort candidates, explore combinations recursively, backtrack when sum exceeds target. Use start index to avoid duplicate combinations.",
    "hints": [
      "Sort candidates array for pruning optimization",
      "Use start index to avoid generating duplicate combinations",
      "Backtrack when current sum exceeds target"
    ],
    "difficulty_score": 5400,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M050",
    "title": "Union-Find: Accounts Merge",
    "slug": "accounts-merge",
    "difficulty": "Medium",
    "points": 5450,
    "topics": ["Union Find", "Hash Table", "String", "DFS"],
    "tags": ["union-find", "disjoint-set", "accounts-merge", "dfs", "hash-table"],
    "statement_markdown": "Master **Union-Find (Disjoint Set Union) data structure**:\n\n1. **Component Merging**: Merge accounts belonging to same person\n2. **Email Mapping**: Track which emails belong to which accounts\n3. **Path Compression**: Optimize find operations for efficiency\n4. **Union by Rank**: Balance tree height during union operations\n5. **Alternative DFS**: Graph-based solution for comparison\n\nImplement efficient algorithms for merging connected components.",
    "input_format": "List of accounts with names and email addresses",
    "output_format": "Merged accounts, union-find analysis, algorithm comparison",
    "constraints": [
      "1 <= accounts.length <= 1000",
      "2 <= accounts[i].length <= 10",
      "1 <= accounts[i][j].length <= 30",
      "accounts[i][0] consists of English letters",
      "accounts[i][j] (for j > 0) is a valid email"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return\n        \n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        \n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n\ndef accountsMerge(accounts):\n    uf = UnionFind(len(accounts))\n    email_to_account = {}\n    \n    for i, account in enumerate(accounts):\n        for email in account[1:]:\n            if email in email_to_account:\n                uf.union(i, email_to_account[email])\n            else:\n                email_to_account[email] = i\n    \n    groups = {}\n    for i in range(len(accounts)):\n        root = uf.find(i)\n        if root not in groups:\n            groups[root] = []\n        groups[root].append(i)\n    \n    result = []\n    for account_indices in groups.values():\n        emails = set()\n        name = accounts[account_indices[0]][0]\n        \n        for idx in account_indices:\n            emails.update(accounts[idx][1:])\n        \n        result.append([name] + sorted(emails))\n    \n    return result",
        "time_complexity": "O(N Ã Î±(N))",
        "space_complexity": "O(N)"
      }
    },
    "editorial": "Use Union-Find to merge accounts with shared emails. Build email-to-account mapping, union accounts sharing emails, group by root, collect all emails per group.",
    "hints": [
      "Use Union-Find to track connected components of accounts",
      "Accounts sharing emails should be in same component",
      "Group accounts by their root and collect all emails"
    ],
    "difficulty_score": 5450,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M051",
    "title": "Greedy Algorithm: Gas Station and Candy Distribution",
    "slug": "gas-station-candy-distribution",
    "difficulty": "Medium",
    "points": 5500,
    "topics": ["Greedy", "Array", "Two Pointers"],
    "tags": ["greedy", "gas-station", "candy-distribution", "circular-array", "optimization"],
    "statement_markdown": "Master **greedy algorithms for resource distribution**:\n\n1. **Gas Station Problem**: Find starting position to complete circular tour\n2. **Candy Distribution**: Minimum candies with neighbor constraints\n3. **Greedy Strategy**: Local optimal choices leading to global optimum\n4. **Circular Arrays**: Handle wraparound and cyclic dependencies\n5. **Optimization**: Single-pass solutions with minimal extra space\n\nImplement efficient greedy algorithms for classic distribution problems.",
    "input_format": "Array of gas/cost values or ratings array",
    "output_format": "Starting index or minimum candy count, detailed algorithm analysis",
    "constraints": [
      "1 <= gas.length, cost.length <= 10^5",
      "0 <= gas[i], cost[i] <= 10^4",
      "1 <= ratings.length <= 2 * 10^4",
      "0 <= ratings[i] <= 2 * 10^4"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def canCompleteCircuit(gas, cost):\n    total_gas = sum(gas)\n    total_cost = sum(cost)\n    \n    if total_gas < total_cost:\n        return -1\n    \n    start = 0\n    current_tank = 0\n    \n    for i in range(len(gas)):\n        current_tank += gas[i] - cost[i]\n        \n        if current_tank < 0:\n            start = i + 1\n            current_tank = 0\n    \n    return start\n\ndef candy(ratings):\n    n = len(ratings)\n    candies = [1] * n\n    \n    # Left to right pass\n    for i in range(1, n):\n        if ratings[i] > ratings[i-1]:\n            candies[i] = candies[i-1] + 1\n    \n    # Right to left pass\n    for i in range(n-2, -1, -1):\n        if ratings[i] > ratings[i+1]:\n            candies[i] = max(candies[i], candies[i+1] + 1)\n    \n    return sum(candies)",
        "time_complexity": "O(n)",
        "space_complexity": "O(n) for candy, O(1) for gas station"
      }
    },
    "editorial": "Use greedy strategy: Gas station tracks current fuel and resets start when tank goes negative. Candy uses two passes to ensure neighbor constraints are satisfied.",
    "hints": [
      "For gas station: if total gas >= total cost, solution exists",
      "For candy: use two passes to handle left and right constraints",
      "Greedy choice: reset starting position when tank becomes negative"
    ],
    "difficulty_score": 5500,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M052",
    "title": "Matrix Traversal: Spiral Pattern Navigation",
    "slug": "spiral-matrix-traversal",
    "difficulty": "Medium",
    "points": 5550,
    "topics": ["Matrix", "Simulation", "Array"],
    "tags": ["spiral-traversal", "matrix-navigation", "boundary-management", "simulation", "2d-array"],
    "statement_markdown": "Master **spiral matrix traversal patterns**:\n\n1. **Boundary Management**: Track and adjust matrix boundaries during traversal\n2. **Direction Control**: Systematic navigation in clockwise/counterclockwise patterns\n3. **Matrix Generation**: Create matrices with spiral number placement\n4. **Edge Cases**: Handle single row, single column, and empty matrices\n5. **Optimization**: Efficient boundary updates and direction changes\n\nImplement robust algorithms for various spiral traversal and generation problems.",
    "input_format": "2D matrix or target size for generation",
    "output_format": "Spiral traversal sequence, generated matrix, algorithm analysis",
    "constraints": [
      "1 <= matrix.length, matrix[i].length <= 10",
      "1 <= n <= 20",
      "-100 <= matrix[i][j] <= 100"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def spiralOrder(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    \n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    \n    while top <= bottom and left <= right:\n        # Move right\n        for col in range(left, right + 1):\n            result.append(matrix[top][col])\n        top += 1\n        \n        # Move down\n        for row in range(top, bottom + 1):\n            result.append(matrix[row][right])\n        right -= 1\n        \n        # Move left\n        if top <= bottom:\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n        \n        # Move up\n        if left <= right:\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n    \n    return result",
        "time_complexity": "O(m Ã n)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "Maintain four boundaries (top, bottom, left, right) and traverse in spiral order. Move right, down, left, up while shrinking boundaries after each direction.",
    "hints": [
      "Use four boundaries to track traversal limits",
      "Move in four directions: right â down â left â up",
      "Check boundary validity before moving left and up"
    ],
    "difficulty_score": 5550,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M053",
    "title": "Bitmask DP: Subset Sum with Small Sets",
    "slug": "subset-sum-bitmask-dp",
    "difficulty": "Medium",
    "points": 5600,
    "topics": ["Dynamic Programming", "Bitmask", "Bit Manipulation"],
    "tags": ["bitmask-dp", "subset-sum", "bit-manipulation", "small-constraints", "exponential-optimization"],
    "statement_markdown": "Master **bitmask dynamic programming for small sets**:\n\n1. **Subset Enumeration**: Use bit patterns to represent all possible subsets\n2. **State Compression**: Encode subset information in integer bits\n3. **Exponential Optimization**: Reduce O(2^n Ã n) to manageable complexity\n4. **Subset Sum Variants**: Target sum, equal partition, maximum subset\n5. **Bit Operations**: Efficient subset manipulation using bitwise operations\n\nImplement efficient bitmask DP solutions for subset problems with small n.",
    "input_format": "Array of integers and target constraints",
    "output_format": "Subset existence, subset enumeration, optimization analysis",
    "constraints": [
      "1 <= nums.length <= 20",
      "1 <= nums[i] <= 1000",
      "1 <= target <= 1000",
      "Sum of all elements <= 2000"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def canPartition(nums, target):\n    n = len(nums)\n    \n    # Enumerate all 2^n subsets using bitmask\n    for mask in range(1 << n):\n        subset_sum = 0\n        \n        # Calculate sum of current subset\n        for i in range(n):\n            if mask & (1 << i):  # Check if element i is included\n                subset_sum += nums[i]\n        \n        if subset_sum == target:\n            return True\n    \n    return False\n\ndef subsetSum_DP(nums, target):\n    dp = [False] * (target + 1)\n    dp[0] = True\n    \n    for num in nums:\n        for j in range(target, num - 1, -1):\n            dp[j] = dp[j] or dp[j - num]\n    \n    return dp[target]",
        "time_complexity": "O(2^n Ã n) for bitmask, O(n Ã target) for DP",
        "space_complexity": "O(1) for bitmask, O(target) for DP"
      }
    },
    "editorial": "For small n, use bitmask to enumerate all subsets and check sums. For larger constraints, use traditional DP with subset sum approach.",
    "hints": [
      "Use bitmask when n â¤ 20 to enumerate all subsets",
      "Each bit position represents inclusion of an element",
      "For larger n, switch to traditional DP approach"
    ],
    "difficulty_score": 5600,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M054",
    "title": "Segment Tree: Range Sum Query with Updates",
    "slug": "range-sum-query-updates",
    "difficulty": "Medium",
    "points": 5650,
    "topics": ["Segment Tree", "Array", "Design"],
    "tags": ["segment-tree", "range-query", "point-update", "binary-tree", "divide-conquer"],
    "statement_markdown": "Master **Segment Tree for range queries and updates**:\n\n1. **Tree Construction**: Build binary tree for efficient range operations\n2. **Range Queries**: Calculate sum/min/max over arbitrary ranges in O(log n)\n3. **Point Updates**: Modify single elements and update tree structure\n4. **Lazy Propagation**: Handle range updates efficiently\n5. **Space Optimization**: Memory-efficient implementation techniques\n\nImplement complete Segment Tree supporting both queries and updates.",
    "input_format": "Array initialization and sequence of update/query operations",
    "output_format": "Query results, tree structure analysis, complexity analysis",
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-100 <= nums[i] <= 100",
      "0 <= index < nums.length",
      "-100 <= val <= 100",
      "0 <= left <= right < nums.length"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "class NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.tree = [0] * (4 * self.n)\n        self.nums = nums[:]\n        self.build(1, 0, self.n - 1)\n    \n    def build(self, node, start, end):\n        if start == end:\n            self.tree[node] = self.nums[start]\n        else:\n            mid = (start + end) // 2\n            self.build(2 * node, start, mid)\n            self.build(2 * node + 1, mid + 1, end)\n            self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]\n    \n    def update(self, index, val):\n        self._update(1, 0, self.n - 1, index, val)\n    \n    def _update(self, node, start, end, idx, val):\n        if start == end:\n            self.tree[node] = val\n        else:\n            mid = (start + end) // 2\n            if idx <= mid:\n                self._update(2 * node, start, mid, idx, val)\n            else:\n                self._update(2 * node + 1, mid + 1, end, idx, val)\n            self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]\n    \n    def sumRange(self, left, right):\n        return self._query(1, 0, self.n - 1, left, right)\n    \n    def _query(self, node, start, end, l, r):\n        if r < start or end < l:\n            return 0\n        if l <= start and end <= r:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return (self._query(2 * node, start, mid, l, r) + \n                self._query(2 * node + 1, mid + 1, end, l, r))",
        "time_complexity": "O(log n) per operation",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Build binary tree where each node stores sum of its range. For queries, traverse tree combining overlapping ranges. For updates, modify leaf and propagate changes upward.",
    "hints": [
      "Use binary tree where each node represents a range sum",
      "For updates, modify leaf node and update all ancestors",
      "For queries, combine results from overlapping ranges"
    ],
    "difficulty_score": 5650,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M055",
    "title": "Hash Map: Subarray Sum Equals K",
    "slug": "subarray-sum-equals-k",
    "difficulty": "Medium",
    "points": 5700,
    "topics": ["Hash Table", "Array", "Prefix Sum"],
    "tags": ["hash-map", "prefix-sum", "subarray", "cumulative-sum", "two-sum-variant"],
    "statement_markdown": "Master **hash-based subarray sum techniques**:\n\n1. **Prefix Sum Concept**: Use cumulative sums to represent subarray sums\n2. **Hash Map Optimization**: Store prefix sums for O(1) lookup\n3. **Subarray Enumeration**: Count all valid subarrays efficiently\n4. **Negative Numbers**: Handle arrays with negative elements\n5. **Variant Problems**: Zero sum, maximum length, product variants\n\nImplement efficient algorithms using hash maps and prefix sum techniques.",
    "input_format": "Array of integers and target sum k",
    "output_format": "Count of subarrays, subarray indices, algorithm analysis",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-1000 <= nums[i] <= 1000",
      "-10^7 <= k <= 10^7"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def subarraySum(nums, k):\n    prefix_sum = 0\n    prefix_count = {0: 1}  # Empty prefix has sum 0\n    result = 0\n    \n    for num in nums:\n        prefix_sum += num\n        \n        # Check if there exists a prefix with sum (prefix_sum - k)\n        target_prefix = prefix_sum - k\n        if target_prefix in prefix_count:\n            result += prefix_count[target_prefix]\n        \n        # Update prefix count\n        prefix_count[prefix_sum] = prefix_count.get(prefix_sum, 0) + 1\n    \n    return result",
        "time_complexity": "O(n)",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use prefix sum with hash map. For each position, check if (current_prefix - k) exists in map, representing a previous prefix making current subarray sum to k.",
    "hints": [
      "Use prefix sums to represent subarray sums efficiently",
      "Store prefix sum frequencies in hash map",
      "For subarray [i,j] with sum k: prefix[j] - prefix[i-1] = k"
    ],
    "difficulty_score": 5700,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M056",
    "title": "Linked List: Deep Copy with Random Pointers",
    "slug": "copy-list-random-pointer",
    "difficulty": "Medium",
    "points": 5750,
    "topics": ["Linked List", "Hash Table", "Recursion"],
    "tags": ["deep-copy", "random-pointer", "linked-list", "hash-map", "node-cloning"],
    "statement_markdown": "Master **deep copying complex linked list structures**:\n\n1. **Random Pointer Challenge**: Handle arbitrary connections between nodes\n2. **Hash Map Approach**: Map original nodes to cloned nodes\n3. **Interweaving Technique**: Clone nodes inline for O(1) space\n4. **Node Relationships**: Preserve both next and random connections\n5. **Memory Management**: Avoid infinite loops and memory leaks\n\nImplement efficient algorithms for cloning linked lists with complex pointer structures.",
    "input_format": "Linked list with next and random pointers",
    "output_format": "Deep copied list, algorithm analysis, space optimization",
    "constraints": [
      "0 <= n <= 1000",
      "-10000 <= Node.val <= 10000",
      "Node.random is null or pointing to any node in the linked list"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def copyRandomList(head):\n    if not head:\n        return None\n    \n    original_to_copy = {}\n    \n    # First pass: create all nodes\n    current = head\n    while current:\n        original_to_copy[current] = Node(current.val)\n        current = current.next\n    \n    # Second pass: set up connections\n    current = head\n    while current:\n        copy_node = original_to_copy[current]\n        if current.next:\n            copy_node.next = original_to_copy[current.next]\n        if current.random:\n            copy_node.random = original_to_copy[current.random]\n        current = current.next\n    \n    return original_to_copy[head]\n\n# O(1) space solution\ndef copyRandomList_O1Space(head):\n    if not head:\n        return None\n    \n    # Interweave original and cloned nodes\n    current = head\n    while current:\n        clone = Node(current.val)\n        clone.next = current.next\n        current.next = clone\n        current = clone.next\n    \n    # Set random pointers for clones\n    current = head\n    while current:\n        if current.random:\n            current.next.random = current.random.next\n        current = current.next.next\n    \n    # Separate the lists\n    original = head\n    clone_head = head.next\n    clone = clone_head\n    \n    while original:\n        original.next = original.next.next if original.next else None\n        clone.next = clone.next.next if clone.next else None\n        original = original.next\n        clone = clone.next\n    \n    return clone_head",
        "time_complexity": "O(n)",
        "space_complexity": "O(n) for hash map, O(1) for interweaving"
      }
    },
    "editorial": "Use hash map to store originalâclone mapping. Create all nodes first, then connect them. For O(1) space, interweave clones with originals, set random pointers, then separate.",
    "hints": [
      "Use hash map to track original node to clone mapping",
      "Create all nodes first, then establish connections",
      "For O(1) space: interweave clones with originals"
    ],
    "difficulty_score": 5750,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M057",
    "title": "Graph Components: Connected Components Counting",
    "slug": "connected-components-counting",
    "difficulty": "Medium",
    "points": 5800,
    "topics": ["Graph", "Union Find", "DFS", "BFS"],
    "tags": ["connected-components", "graph-traversal", "union-find", "dfs", "bfs"],
    "statement_markdown": "Master **connected components analysis in graphs**:\n\n1. **Component Detection**: Identify separate connected regions\n2. **DFS/BFS Traversal**: Explore all nodes in each component\n3. **Union-Find Optimization**: Efficient component tracking with updates\n4. **Edge Cases**: Isolated nodes, self-loops, disconnected graphs\n5. **Dynamic Updates**: Handle edge additions/removals efficiently\n\nImplement multiple algorithms for counting and analyzing graph components.",
    "input_format": "Number of nodes and list of edges",
    "output_format": "Component count, component analysis, algorithm comparison",
    "constraints": [
      "1 <= n <= 2000",
      "1 <= edges.length <= 5000",
      "edges[i].length == 2",
      "0 <= ai, bi < n",
      "ai != bi",
      "No duplicate edges"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def countComponents(n, edges):\n    # DFS approach\n    adj = [[] for _ in range(n)]\n    for a, b in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    visited = [False] * n\n    count = 0\n    \n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n    \n    for i in range(n):\n        if not visited[i]:\n            count += 1\n            dfs(i)\n    \n    return count\n\n# Union-Find approach\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.components = n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px != py:\n            self.parent[py] = px\n            self.components -= 1\n\ndef countComponents_UF(n, edges):\n    uf = UnionFind(n)\n    for a, b in edges:\n        uf.union(a, b)\n    return uf.components",
        "time_complexity": "O(V + E) for DFS, O(E Ã Î±(V)) for Union-Find",
        "space_complexity": "O(V)"
      }
    },
    "editorial": "Use DFS/BFS to traverse graph and count components, or Union-Find to merge connected nodes. DFS: visit unvisited nodes, explore all reachable nodes, increment count.",
    "hints": [
      "Use DFS or BFS to explore each connected component",
      "Track visited nodes to avoid counting same component twice", 
      "Union-Find alternative: merge connected nodes, count remaining roots"
    ],
    "difficulty_score": 5800,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M058",
    "title": "Topological Sort: Alien Dictionary Character Ordering",
    "slug": "alien-dictionary-topological-sort",
    "difficulty": "Medium",
    "points": 5850,
    "topics": ["Topological Sort", "Graph", "Array", "String"],
    "tags": ["topological-sort", "alien-dictionary", "character-ordering", "dfs", "kahn-algorithm"],
    "statement_markdown": "Master **topological sorting for character ordering**:\n\n1. **Character Dependencies**: Extract ordering rules from word sequences\n2. **Graph Construction**: Build directed graph representing character precedence\n3. **Cycle Detection**: Identify impossible orderings due to contradictions\n4. **Kahn's Algorithm**: BFS-based topological sorting approach\n5. **DFS-based Sorting**: Alternative recursive approach with cycle detection\n\nImplement robust algorithms for determining character ordering from alien dictionaries.",
    "input_format": "Array of words in alien dictionary order",
    "output_format": "Character ordering string, algorithm analysis, contradiction detection",
    "constraints": [
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 20",
      "words[i] consists of only lowercase English letters"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def alienOrder(words):\n    adj = {}\n    in_degree = {}\n    \n    # Initialize graph\n    for word in words:\n        for char in word:\n            adj[char] = []\n            in_degree[char] = 0\n    \n    # Build graph from word comparisons\n    for i in range(len(words) - 1):\n        word1, word2 = words[i], words[i + 1]\n        min_len = min(len(word1), len(word2))\n        \n        # Check invalid case\n        if len(word1) > len(word2) and word1[:min_len] == word2:\n            return \"\"\n        \n        # Find first differing character\n        for j in range(min_len):\n            if word1[j] != word2[j]:\n                if word2[j] not in adj[word1[j]]:\n                    adj[word1[j]].append(word2[j])\n                    in_degree[word2[j]] += 1\n                break\n    \n    # Topological sort using Kahn's algorithm\n    queue = [char for char in in_degree if in_degree[char] == 0]\n    result = []\n    \n    while queue:\n        char = queue.pop(0)\n        result.append(char)\n        \n        for neighbor in adj[char]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check if all characters processed (no cycle)\n    return ''.join(result) if len(result) == len(in_degree) else \"\"",
        "time_complexity": "O(C + min(NÂ², C))",
        "space_complexity": "O(C)"
      }
    },
    "editorial": "Compare adjacent words to extract character precedence rules, build directed graph, apply topological sort. Handle invalid orderings and cycle detection.",
    "hints": [
      "Compare adjacent words to find character precedence rules",
      "Build directed graph representing character ordering",
      "Use topological sort to find valid character sequence"
    ],
    "difficulty_score": 5850,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M059",
    "title": "Monotonic Stack: Next Greater Element Variants",
    "slug": "next-greater-element-variants",
    "difficulty": "Medium",
    "points": 5900,
    "topics": ["Stack", "Array", "Monotonic Stack"],
    "tags": ["monotonic-stack", "next-greater-element", "circular-array", "stack-optimization", "preprocessing"],
    "statement_markdown": "Master **monotonic stack for element relationship problems**:\n\n1. **Next Greater Element**: Find next larger element for each position\n2. **Circular Arrays**: Handle wraparound using array doubling technique\n3. **Monotonic Properties**: Maintain increasing/decreasing stack order\n4. **Temperature Problems**: Days until warmer temperature\n5. **Stack Optimization**: Efficient O(n) preprocessing for range queries\n\nImplement efficient monotonic stack algorithms for various element comparison problems.",
    "input_format": "Array of integers or temperatures",
    "output_format": "Next greater elements array, algorithm analysis, optimization techniques",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^4",
      "Array elements can be duplicates"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def nextGreaterElements(nums):\n    stack = []\n    result = [-1] * len(nums)\n    \n    for i, num in enumerate(nums):\n        while stack and nums[stack[-1]] < num:\n            index = stack.pop()\n            result[index] = num\n        stack.append(i)\n    \n    return result\n\ndef nextGreaterElementsCircular(nums):\n    n = len(nums)\n    stack = []\n    result = [-1] * n\n    \n    for i in range(2 * n):\n        num = nums[i % n]\n        \n        while stack and nums[stack[-1]] < num:\n            index = stack.pop()\n            result[index] = num\n        \n        if i < n:\n            stack.append(i)\n    \n    return result\n\ndef dailyTemperatures(temperatures):\n    stack = []\n    result = [0] * len(temperatures)\n    \n    for i, temp in enumerate(temperatures):\n        while stack and temperatures[stack[-1]] < temp:\n            prev_day = stack.pop()\n            result[prev_day] = i - prev_day\n        stack.append(i)\n    \n    return result",
        "time_complexity": "O(n)",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use monotonic decreasing stack to track potential candidates. When current element is greater than stack top, pop and record result. For circular arrays, process twice.",
    "hints": [
      "Use monotonic stack to maintain decreasing order",
      "Pop stack when current element is greater than top",
      "For circular arrays, process the array twice"
    ],
    "difficulty_score": 5900,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M060",
    "title": "Heap Design: Find Median from Data Stream",
    "slug": "find-median-data-stream",
    "difficulty": "Medium",
    "points": 5950,
    "topics": ["Heap", "Design", "Two Pointers", "Data Stream"],
    "tags": ["median", "two-heaps", "data-stream", "priority-queue", "heap-balancing"],
    "statement_markdown": "Master **two-heap technique for dynamic median calculation**:\n\n1. **Heap Balance**: Maintain two heaps for efficient median access\n2. **Max-Min Heap Pair**: Lower half in max-heap, upper half in min-heap\n3. **Size Management**: Keep heap sizes balanced (differ by at most 1)\n4. **Insertion Strategy**: Route elements to appropriate heap\n5. **Rebalancing**: Move elements between heaps to maintain invariant\n\nImplement efficient data structure for real-time median calculation from streaming data.",
    "input_format": "Sequence of addNum and findMedian operations",
    "output_format": "Median values, heap analysis, balancing operations",
    "constraints": [
      "1 <= num <= 10^5",
      "At most 5 * 10^4 calls to addNum and findMedian",
      "-10^5 <= num <= 10^5"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.max_heap = []  # For smaller half (negated values)\n        self.min_heap = []  # For larger half\n    \n    def addNum(self, num):\n        # Add to max_heap first\n        heapq.heappush(self.max_heap, -num)\n        \n        # Move max to min_heap to maintain order\n        val = -heapq.heappop(self.max_heap)\n        heapq.heappush(self.min_heap, val)\n        \n        # Balance heaps\n        if len(self.min_heap) > len(self.max_heap):\n            val = heapq.heappop(self.min_heap)\n            heapq.heappush(self.max_heap, -val)\n    \n    def findMedian(self):\n        if len(self.max_heap) > len(self.min_heap):\n            return float(-self.max_heap[0])\n        else:\n            return (-self.max_heap[0] + self.min_heap[0]) / 2.0",
        "time_complexity": "O(log n) for addNum, O(1) for findMedian",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use two heaps: max-heap for smaller half, min-heap for larger half. Maintain balanced sizes. Median is heap top (if unequal) or average of tops (if equal).",
    "hints": [
      "Use two heaps to split data into smaller and larger halves",
      "Keep heap sizes balanced (differ by at most 1)",
      "Median is top of larger heap or average of both tops"
    ],
    "difficulty_score": 5950,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M061",
    "title": "Binary Search: Rotated Sorted Array Search",
    "slug": "search-rotated-sorted-array",
    "difficulty": "Medium",
    "points": 6000,
    "topics": ["Binary Search", "Array", "Divide and Conquer"],
    "tags": ["rotated-array", "binary-search", "pivot-detection", "sorted-array", "search-algorithm"],
    "statement_markdown": "Master **binary search in rotated sorted arrays**:\n\n1. **Rotation Detection**: Identify the pivot point where rotation occurs\n2. **Modified Binary Search**: Adapt search logic for rotated structure\n3. **Range Analysis**: Determine which half maintains sorted order\n4. **Duplicate Handling**: Manage arrays with duplicate elements\n5. **Edge Cases**: Handle single elements, no rotation, and boundary conditions\n\nImplement efficient search algorithms for finding targets in rotated sorted arrays.",
    "input_format": "Rotated sorted array and target value",
    "output_format": "Target index or -1 if not found, algorithm analysis, complexity breakdown",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i] <= 10^4",
      "All values in nums are unique",
      "-10^4 <= target <= 10^4"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        \n        # Determine which half is sorted\n        if nums[left] <= nums[mid]:  # Left half is sorted\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:  # Right half is sorted\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return -1\n\n# Find minimum element (rotation point)\ndef findMin(nums):\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return nums[left]",
        "time_complexity": "O(log n)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "Use modified binary search. At each step, determine which half is sorted by comparing boundary elements. Check if target lies within sorted half's range.",
    "hints": [
      "Identify which half of array is sorted at each binary search step",
      "Check if target lies within the range of the sorted half",
      "Handle rotation point by comparing left and mid elements"
    ],
    "difficulty_score": 6000,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M062",
    "title": "Two Pointers: 3Sum Closest and Variants",
    "slug": "three-sum-closest-variants",
    "difficulty": "Medium",
    "points": 6050,
    "topics": ["Two Pointers", "Array", "Sorting"],
    "tags": ["3sum", "closest-sum", "two-pointers", "triplet-sum", "optimization"],
    "statement_markdown": "Master **3Sum variants using two-pointer technique**:\n\n1. **3Sum Closest**: Find triplet with sum closest to target\n2. **3Sum Exact**: Find all unique triplets that sum to zero\n3. **Two-Pointer Optimization**: Efficient O(nÂ²) solution approach\n4. **Duplicate Handling**: Skip duplicate combinations efficiently\n5. **Distance Minimization**: Track and update minimum difference\n\nImplement robust algorithms for various triplet sum problems with optimal complexity.",
    "input_format": "Array of integers and target sum",
    "output_format": "Closest sum value, all valid triplets, algorithm analysis",
    "constraints": [
      "3 <= nums.length <= 1000",
      "-1000 <= nums[i] <= 1000",
      "-10^4 <= target <= 10^4",
      "Array may contain duplicates"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def threeSumClosest(nums, target):\n    nums.sort()\n    n = len(nums)\n    closest_sum = float('inf')\n    \n    for i in range(n - 2):\n        left, right = i + 1, n - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if abs(target - current_sum) < abs(target - closest_sum):\n                closest_sum = current_sum\n            \n            if current_sum < target:\n                left += 1\n            elif current_sum > target:\n                right -= 1\n            else:\n                return current_sum\n    \n    return closest_sum\n\ndef threeSum(nums):\n    nums.sort()\n    result = []\n    n = len(nums)\n    \n    for i in range(n - 2):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        \n        left, right = i + 1, n - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == 0:\n                result.append([nums[i], nums[left], nums[right]])\n                \n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                \n                left += 1\n                right -= 1\n            elif current_sum < 0:\n                left += 1\n            else:\n                right -= 1\n    \n    return result",
        "time_complexity": "O(nÂ²)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "Sort array first. For each element, use two pointers on remaining elements to find closest sum. Handle duplicates by skipping identical consecutive values.",
    "hints": [
      "Sort the array first to enable two-pointer technique",
      "For each first element, use two pointers on the remaining subarray", 
      "Track minimum difference to update closest sum"
    ],
    "difficulty_score": 6050,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M063",
    "title": "Sliding Window: Minimum Window Substring",
    "slug": "minimum-window-substring",
    "difficulty": "Medium",
    "points": 6100,
    "topics": ["Sliding Window", "Hash Table", "String", "Two Pointers"],
    "tags": ["sliding-window", "minimum-window", "substring", "hash-map", "character-frequency"],
    "statement_markdown": "Master **sliding window technique for minimum window problems**:\n\n1. **Window Expansion**: Grow window until all requirements satisfied\n2. **Window Contraction**: Shrink window while maintaining validity\n3. **Character Frequency**: Track required vs actual character counts\n4. **Optimization**: Find minimum valid window efficiently\n5. **Edge Cases**: Handle missing characters, duplicate requirements, empty strings\n\nImplement efficient algorithms for finding minimum window containing all required characters.",
    "input_format": "Source string and target pattern string",
    "output_format": "Minimum window substring, algorithm analysis, window tracking",
    "constraints": [
      "1 <= s.length, t.length <= 10^5",
      "s and t consist of uppercase and lowercase English letters",
      "t contains unique characters (for basic version)"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def minWindow(s, t):\n    if not s or not t:\n        return \"\"\n    \n    dict_t = {}\n    for char in t:\n        dict_t[char] = dict_t.get(char, 0) + 1\n    \n    required = len(dict_t)\n    formed = 0\n    window_counts = {}\n    \n    left = right = 0\n    ans = float('inf'), None, None\n    \n    while right < len(s):\n        char = s[right]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        \n        if char in dict_t and window_counts[char] == dict_t[char]:\n            formed += 1\n        \n        while left <= right and formed == required:\n            char = s[left]\n            \n            if right - left + 1 < ans[0]:\n                ans = (right - left + 1, left, right)\n            \n            window_counts[char] -= 1\n            if char in dict_t and window_counts[char] < dict_t[char]:\n                formed -= 1\n            \n            left += 1\n        \n        right += 1\n    \n    return \"\" if ans[0] == float('inf') else s[ans[1]:ans[2] + 1]",
        "time_complexity": "O(|S| + |T|)",
        "space_complexity": "O(|S| + |T|)"
      }
    },
    "editorial": "Use sliding window technique. Expand right pointer until window contains all required characters, then contract left pointer while maintaining validity.",
    "hints": [
      "Use sliding window with two pointers to track current window",
      "Expand window until all required characters are included",
      "Contract window from left while maintaining all requirements"
    ],
    "difficulty_score": 6100,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M064",
    "title": "DFS/BFS: Number of Islands in Grid",
    "slug": "number-of-islands-grid",
    "difficulty": "Medium",
    "points": 6150,
    "topics": ["DFS", "BFS", "Grid", "Union Find"],
    "tags": ["islands", "grid-traversal", "connected-components", "dfs", "bfs", "flood-fill"],
    "statement_markdown": "Master **grid traversal for island counting problems**:\n\n1. **DFS Traversal**: Explore islands using depth-first search\n2. **BFS Traversal**: Alternative breadth-first exploration approach\n3. **Grid Navigation**: Handle 4-directional movement with boundaries\n4. **Island Marking**: Track visited cells to avoid double counting\n5. **Connected Components**: Identify separate landmass regions\n\nImplement efficient algorithms for counting disconnected regions in 2D grids.",
    "input_format": "2D binary grid where 1 represents land and 0 represents water",
    "output_format": "Number of islands, algorithm analysis, traversal visualization",
    "constraints": [
      "1 <= grid.length <= 300",
      "1 <= grid[0].length <= 300",
      "grid[i][j] is '0' or '1'"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def numIslands(grid):\n    if not grid or not grid[0]:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    island_count = 0\n    \n    def dfs(r, c):\n        if (r < 0 or r >= rows or c < 0 or c >= cols or \n            grid[r][c] == '0'):\n            return\n        \n        grid[r][c] = '0'  # Mark as visited\n        \n        # Explore all 4 directions\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                island_count += 1\n                dfs(r, c)\n    \n    return island_count\n\n# BFS alternative\nfrom collections import deque\n\ndef numIslandsBFS(grid):\n    if not grid or not grid[0]:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    island_count = 0\n    \n    def bfs(start_r, start_c):\n        queue = deque([(start_r, start_c)])\n        grid[start_r][start_c] = '0'\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        \n        while queue:\n            r, c = queue.popleft()\n            \n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                \n                if (0 <= nr < rows and 0 <= nc < cols and \n                    grid[nr][nc] == '1'):\n                    grid[nr][nc] = '0'\n                    queue.append((nr, nc))\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '1':\n                island_count += 1\n                bfs(r, c)\n    \n    return island_count",
        "time_complexity": "O(m Ã n)",
        "space_complexity": "O(m Ã n)"
      }
    },
    "editorial": "Use DFS or BFS to explore connected land cells. For each unvisited '1' cell, increment island count and mark entire connected component as visited.",
    "hints": [
      "Use DFS or BFS to explore each island completely",
      "Mark visited land cells to avoid counting same island twice",
      "Each connected component of '1's represents one island"
    ],
    "difficulty_score": 6150,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M065",
    "title": "Dynamic Programming: Longest Increasing Subsequence",
    "slug": "longest-increasing-subsequence",
    "difficulty": "Medium",
    "points": 6200,
    "topics": ["Dynamic Programming", "Binary Search", "Array"],
    "tags": ["lis", "longest-subsequence", "dynamic-programming", "binary-search", "patience-sorting"],
    "statement_markdown": "Master **longest increasing subsequence algorithms**:\n\n1. **DP Approach**: O(nÂ²) dynamic programming solution\n2. **Binary Search Optimization**: O(n log n) optimized approach\n3. **Patience Sorting**: Greedy algorithm with binary search\n4. **Subsequence Reconstruction**: Track actual LIS elements\n5. **Variants**: Longest decreasing, non-decreasing, strictly increasing\n\nImplement efficient algorithms for finding longest increasing subsequences with optimal complexity.",
    "input_format": "Array of integers",
    "output_format": "Length of LIS, actual subsequence, algorithm analysis",
    "constraints": [
      "1 <= nums.length <= 2500",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def lengthOfLIS(nums):\n    if not nums:\n        return 0\n    \n    # O(n^2) DP solution\n    n = len(nums)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n# O(n log n) Binary Search solution\nimport bisect\n\ndef lengthOfLIS_Optimized(nums):\n    tails = []\n    \n    for num in nums:\n        pos = bisect.bisect_left(tails, num)\n        if pos == len(tails):\n            tails.append(num)\n        else:\n            tails[pos] = num\n    \n    return len(tails)",
        "time_complexity": "O(nÂ²) for DP, O(n log n) for binary search",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use DP where dp[i] represents longest increasing subsequence ending at index i. For optimization, use binary search with patience sorting approach.",
    "hints": [
      "Use DP where dp[i] = length of LIS ending at index i",
      "For each position, check all previous positions with smaller values",
      "Optimize with binary search using patience sorting technique"
    ],
    "difficulty_score": 6200,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M066",
    "title": "Heap: Merge K Sorted Lists",
    "slug": "merge-k-sorted-lists",
    "difficulty": "Medium",
    "points": 6250,
    "topics": ["Heap", "Linked List", "Divide and Conquer", "Priority Queue"],
    "tags": ["merge-sort", "k-way-merge", "priority-queue", "linked-list", "divide-conquer"],
    "statement_markdown": "Master **k-way merge algorithms using heaps**:\n\n1. **Priority Queue Approach**: Use min-heap for efficient merging\n2. **Divide and Conquer**: Recursively merge pairs of lists\n3. **Sequential Merging**: Merge lists one by one with optimization\n4. **Linked List Manipulation**: Handle node connections efficiently\n5. **Memory Management**: Minimize space complexity with in-place operations\n\nImplement efficient algorithms for merging multiple sorted linked lists.",
    "input_format": "Array of sorted linked list heads",
    "output_format": "Merged sorted linked list, algorithm analysis, complexity breakdown",
    "constraints": [
      "k == lists.length",
      "0 <= k <= 10^4",
      "0 <= lists[i].length <= 500",
      "-10^4 <= lists[i][j] <= 10^4",
      "lists[i] is sorted in ascending order"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "import heapq\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    \n    def __lt__(self, other):\n        return self.val < other.val\n\ndef mergeKLists(lists):\n    # Priority Queue approach\n    heap = []\n    \n    for head in lists:\n        if head:\n            heapq.heappush(heap, head)\n    \n    dummy = ListNode(0)\n    current = dummy\n    \n    while heap:\n        min_node = heapq.heappop(heap)\n        current.next = min_node\n        current = current.next\n        \n        if min_node.next:\n            heapq.heappush(heap, min_node.next)\n    \n    return dummy.next\n\n# Alternative: Divide and Conquer\ndef mergeKLists_DC(lists):\n    if not lists:\n        return None\n    \n    def mergeTwoLists(l1, l2):\n        dummy = ListNode(0)\n        current = dummy\n        \n        while l1 and l2:\n            if l1.val <= l2.val:\n                current.next = l1\n                l1 = l1.next\n            else:\n                current.next = l2\n                l2 = l2.next\n            current = current.next\n        \n        current.next = l1 or l2\n        return dummy.next\n    \n    while len(lists) > 1:\n        merged_lists = []\n        \n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 < len(lists) else None\n            merged_lists.append(mergeTwoLists(l1, l2))\n        \n        lists = merged_lists\n    \n    return lists[0]",
        "time_complexity": "O(N log k) where N = total nodes, k = number of lists",
        "space_complexity": "O(k) for heap approach, O(log k) for divide-and-conquer"
      }
    },
    "editorial": "Use min-heap to efficiently select smallest element among all list heads, or use divide-and-conquer to recursively merge pairs of lists.",
    "hints": [
      "Use priority queue to always get the minimum element from all list heads",
      "Alternative: divide and conquer by merging pairs of lists recursively",
      "Remember to handle the next pointer when extracting from heap"
    ],
    "difficulty_score": 6250,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M067",
    "title": "Graph: Course Scheduling and Cycle Detection",
    "slug": "course-scheduling-topological-sort",
    "difficulty": "Medium",
    "points": 6300,
    "topics": ["Graph", "Topological Sort", "DFS", "BFS"],
    "tags": ["topological-sort", "cycle-detection", "course-scheduling", "prerequisite", "dependency-graph"],
    "statement_markdown": "Master **topological sorting and cycle detection in directed graphs**:\n\n1. **Course Prerequisites**: Model course dependencies as directed graph\n2. **Cycle Detection**: Identify impossible scheduling due to circular dependencies\n3. **Kahn's Algorithm**: BFS-based topological sorting with in-degree tracking\n4. **DFS-based Sorting**: Recursive approach with color-coding for cycle detection\n5. **Schedule Generation**: Produce valid course ordering when possible\n\nImplement robust algorithms for dependency resolution and circular dependency detection.",
    "input_format": "Number of courses and prerequisite pairs",
    "output_format": "Boolean feasibility, valid course order, cycle analysis",
    "constraints": [
      "1 <= numCourses <= 2000",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= ai, bi < numCourses",
      "All prerequisite pairs are unique"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "from collections import deque, defaultdict\n\ndef canFinish(numCourses, prerequisites):\n    # Kahn's Algorithm\n    adj = defaultdict(list)\n    in_degree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        adj[prereq].append(course)\n        in_degree[course] += 1\n    \n    queue = deque([i for i in range(numCourses) if in_degree[i] == 0])\n    processed = 0\n    \n    while queue:\n        current = queue.popleft()\n        processed += 1\n        \n        for neighbor in adj[current]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return processed == numCourses\n\ndef findOrder(numCourses, prerequisites):\n    adj = defaultdict(list)\n    in_degree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        adj[prereq].append(course)\n        in_degree[course] += 1\n    \n    queue = deque([i for i in range(numCourses) if in_degree[i] == 0])\n    result = []\n    \n    while queue:\n        current = queue.popleft()\n        result.append(current)\n        \n        for neighbor in adj[current]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result if len(result) == numCourses else []",
        "time_complexity": "O(V + E)",
        "space_complexity": "O(V + E)"
      }
    },
    "editorial": "Use topological sorting to detect cycles and find valid course ordering. Kahn's algorithm with BFS and in-degree tracking is most intuitive approach.",
    "hints": [
      "Model the problem as a directed graph with courses as nodes",
      "Use topological sorting to detect cycles in dependencies",
      "Kahn's algorithm: start with courses having no prerequisites"
    ],
    "difficulty_score": 6300,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M068",
    "title": "Trie: Implement Prefix Tree Data Structure",
    "slug": "implement-trie-prefix-tree",
    "difficulty": "Medium",
    "points": 6350,
    "topics": ["Trie", "Design", "String", "Hash Table"],
    "tags": ["trie", "prefix-tree", "autocomplete", "word-search", "string-matching"],
    "statement_markdown": "Master **Trie (Prefix Tree) implementation and applications**:\n\n1. **Node Structure**: Design efficient Trie node with children mapping\n2. **Word Insertion**: Add words while building prefix structure\n3. **Word Search**: Query for complete word existence\n4. **Prefix Matching**: Check if any words start with given prefix\n5. **Advanced Operations**: Deletion, wildcard search, auto-completion\n\nImplement comprehensive Trie data structure supporting various string operations efficiently.",
    "input_format": "Sequence of insert, search, and startsWith operations",
    "output_format": "Boolean results for queries, Trie structure analysis, operation complexity",
    "constraints": [
      "1 <= word.length, prefix.length <= 2000",
      "word and prefix consist only of lowercase English letters",
      "At most 3 * 10^4 calls to insert, search, and startsWith"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        current = self.root\n        \n        for char in word:\n            if char not in current.children:\n                current.children[char] = TrieNode()\n            current = current.children[char]\n        \n        current.is_end_word = True\n    \n    def search(self, word):\n        current = self.root\n        \n        for char in word:\n            if char not in current.children:\n                return False\n            current = current.children[char]\n        \n        return current.is_end_word\n    \n    def startsWith(self, prefix):\n        current = self.root\n        \n        for char in prefix:\n            if char not in current.children:\n                return False\n            current = current.children[char]\n        \n        return True",
        "time_complexity": "O(m) for all operations where m is word/prefix length",
        "space_complexity": "O(ALPHABET_SIZE Ã N Ã M)"
      }
    },
    "editorial": "Implement Trie using nodes with character-to-node mappings and end-word flags. Build prefix structure during insertion, traverse for search operations.",
    "hints": [
      "Use nested nodes where each node represents a character position",
      "Mark nodes where complete words end with a boolean flag",
      "Share common prefixes by reusing existing paths in the tree"
    ],
    "difficulty_score": 6350,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M069",
    "title": "Backtracking: Combination Sum Variants",
    "slug": "combination-sum-variants",
    "difficulty": "Medium",
    "points": 6400,
    "topics": ["Backtracking", "Array", "Recursion"],
    "tags": ["combination-sum", "backtracking", "subset-generation", "target-sum", "duplicate-handling"],
    "statement_markdown": "Master **backtracking for combination sum problems**:\n\n1. **Basic Combination Sum**: Find all combinations that sum to target (unlimited use)\n2. **Combination Sum II**: Handle duplicates, each element used at most once\n3. **Combination Sum III**: Fixed combination size with digit constraints\n4. **Pruning Optimization**: Early termination to improve efficiency\n5. **Duplicate Management**: Skip duplicate combinations systematically\n\nImplement comprehensive backtracking solutions for various combination sum variants.",
    "input_format": "Array of candidates and target sum with variant-specific constraints",
    "output_format": "All valid combinations, algorithm analysis, pruning strategies",
    "constraints": [
      "1 <= candidates.length <= 30",
      "2 <= candidates[i] <= 40",
      "1 <= target <= 40",
      "All numbers in candidates are unique (for basic version)"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def combinationSum(candidates, target):\n    result = []\n    \n    def backtrack(combination, remaining_target, start):\n        if remaining_target == 0:\n            result.append(combination[:])\n            return\n        \n        for i in range(start, len(candidates)):\n            candidate = candidates[i]\n            \n            if candidate > remaining_target:\n                continue\n            \n            combination.append(candidate)\n            backtrack(combination, remaining_target - candidate, i)\n            combination.pop()\n    \n    backtrack([], target, 0)\n    return result\n\ndef combinationSum2(candidates, target):\n    candidates.sort()\n    result = []\n    \n    def backtrack(combination, remaining_target, start):\n        if remaining_target == 0:\n            result.append(combination[:])\n            return\n        \n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            \n            candidate = candidates[i]\n            \n            if candidate > remaining_target:\n                break\n            \n            combination.append(candidate)\n            backtrack(combination, remaining_target - candidate, i + 1)\n            combination.pop()\n    \n    backtrack([], target, 0)\n    return result\n\ndef combinationSum3(k, n):\n    result = []\n    \n    def backtrack(combination, remaining_target, start):\n        if len(combination) == k:\n            if remaining_target == 0:\n                result.append(combination[:])\n            return\n        \n        for i in range(start, 10):\n            if i > remaining_target:\n                break\n            \n            combination.append(i)\n            backtrack(combination, remaining_target - i, i + 1)\n            combination.pop()\n    \n    backtrack([], n, 1)\n    return result",
        "time_complexity": "O(N^(T/M)) for unlimited use, O(2^N) for limited use",
        "space_complexity": "O(T/M) for recursion depth"
      }
    },
    "editorial": "Use backtracking to explore all combinations. Include current candidate and recurse, then backtrack. Handle duplicates by sorting and skipping consecutive duplicates.",
    "hints": [
      "Use backtracking to explore all possible combinations systematically",
      "Include current candidate in combination, recurse, then backtrack",
      "For duplicates: sort array and skip consecutive duplicates at same level"
    ],
    "difficulty_score": 6400,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M070",
    "title": "Union Find: Accounts Merge",
    "slug": "accounts-merge-union-find",
    "difficulty": "Medium",
    "points": 6450,
    "topics": ["Union Find", "Hash Table", "String", "DFS"],
    "tags": ["union-find", "account-merging", "email-clustering", "connected-components", "graph-traversal"],
    "statement_markdown": "Master **Union-Find for account merging problems**:\n\n1. **Email Clustering**: Group accounts with shared email addresses\n2. **Union-Find Structure**: Efficiently merge and track connected accounts\n3. **Name Association**: Maintain account names through merging process\n4. **Email Sorting**: Present merged results in lexicographical order\n5. **Graph Alternative**: DFS-based approach for connected components\n\nImplement efficient algorithms for merging accounts based on shared email addresses.",
    "input_format": "List of accounts, each containing name and email addresses",
    "output_format": "Merged accounts with sorted emails, algorithm analysis, clustering results",
    "constraints": [
      "1 <= accounts.length <= 1000",
      "2 <= accounts[i].length <= 10",
      "1 <= accounts[i][j].length <= 30",
      "accounts[i][0] is a name",
      "accounts[i][j] for j > 0 is an email"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "from collections import defaultdict\n\ndef accountsMerge(accounts):\n    n = len(accounts)\n    parent = list(range(n))\n    rank = [0] * n\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px == py:\n            return\n        \n        if rank[px] < rank[py]:\n            parent[px] = py\n        elif rank[px] > rank[py]:\n            parent[py] = px\n        else:\n            parent[py] = px\n            rank[px] += 1\n    \n    # Map emails to account indices\n    email_to_accounts = defaultdict(list)\n    for i, account in enumerate(accounts):\n        for email in account[1:]:\n            email_to_accounts[email].append(i)\n    \n    # Union accounts with shared emails\n    for account_list in email_to_accounts.values():\n        for i in range(1, len(account_list)):\n            union(account_list[0], account_list[i])\n    \n    # Group accounts by root\n    root_to_accounts = defaultdict(list)\n    for i in range(n):\n        root_to_accounts[find(i)].append(i)\n    \n    # Build result\n    result = []\n    for account_group in root_to_accounts.values():\n        name = accounts[account_group[0]][0]\n        emails = set()\n        for idx in account_group:\n            emails.update(accounts[idx][1:])\n        result.append([name] + sorted(emails))\n    \n    return result",
        "time_complexity": "O(N Ã Î±(N) + M log M)",
        "space_complexity": "O(N + M)"
      }
    },
    "editorial": "Use Union-Find to group accounts sharing emails. Map each email to account indices, union accounts with common emails, then collect and sort emails by group.",
    "hints": [
      "Use Union-Find to efficiently merge accounts with shared emails",
      "Map each email address to the account indices that contain it",
      "Group accounts by their root parent and collect all emails"
    ],
    "difficulty_score": 6450,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M071",
    "title": "Greedy Algorithm: Gas Station Circuit",
    "slug": "gas-station-circuit-greedy",
    "difficulty": "Medium",
    "points": 6500,
    "topics": ["Greedy", "Array", "Math"],
    "tags": ["greedy-algorithm", "circular-array", "optimization", "fuel-efficiency", "circuit-completion"],
    "statement_markdown": "Master **Greedy algorithms for circuit completion problems**:\n\n1. **Circuit Feasibility**: Determine if complete circuit traversal is possible\n2. **Starting Point Selection**: Find optimal starting position using greedy strategy\n3. **Fuel Management**: Track fuel balance throughout the journey\n4. **Optimization Techniques**: Single-pass and two-pass approaches\n5. **Edge Case Handling**: Insufficient fuel and impossible circuits\n\nImplement efficient algorithms for determining circuit completion feasibility.",
    "input_format": "Gas stations with fuel amounts and distances to next station",
    "output_format": "Starting station index for circuit completion, algorithm analysis",
    "constraints": [
      "1 <= gas.length <= 10^5",
      "gas.length == cost.length",
      "0 <= gas[i], cost[i] <= 10^4"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def canCompleteCircuit(gas, cost):\n    n = len(gas)\n    total_gas = sum(gas)\n    total_cost = sum(cost)\n    \n    if total_gas < total_cost:\n        return -1\n    \n    start = 0\n    tank = 0\n    \n    for i in range(n):\n        tank += gas[i] - cost[i]\n        \n        if tank < 0:\n            start = i + 1\n            tank = 0\n    \n    return start",
        "time_complexity": "O(n)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "Use greedy algorithm to find starting station. If total gas >= total cost, solution exists. Reset start when fuel goes negative.",
    "hints": [
      "Check if total gas is sufficient for the entire circuit",
      "Use greedy approach: reset starting point when fuel becomes negative",
      "Track cumulative fuel balance throughout the journey"
    ],
    "difficulty_score": 6500,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M072",
    "title": "Matrix Traversal: Spiral Matrix Pattern",
    "slug": "spiral-matrix-traversal",
    "difficulty": "Medium",
    "points": 6550,
    "topics": ["Matrix", "Simulation", "Array"],
    "tags": ["matrix-traversal", "spiral-pattern", "boundary-management", "direction-control", "2d-array"],
    "statement_markdown": "Master **Matrix spiral traversal algorithms**:\n\n1. **Boundary Management**: Track and update matrix boundaries during traversal\n2. **Direction Control**: Systematically change directions (rightâdownâleftâup)\n3. **Termination Conditions**: Detect when all elements are visited\n4. **Edge Case Handling**: Single row, single column, and empty matrices\n5. **Pattern Variations**: Clockwise, counter-clockwise, and custom patterns\n\nImplement efficient algorithms for systematic matrix traversal patterns.",
    "input_format": "2D matrix with integer elements",
    "output_format": "Elements in spiral order, algorithm analysis, traversal patterns",
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 10",
      "-100 <= matrix[i][j] <= 100"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def spiralOrder(matrix):\n    if not matrix or not matrix[0]:\n        return []\n    \n    m, n = len(matrix), len(matrix[0])\n    result = []\n    \n    top, bottom = 0, m - 1\n    left, right = 0, n - 1\n    \n    while top <= bottom and left <= right:\n        # Right\n        for col in range(left, right + 1):\n            result.append(matrix[top][col])\n        top += 1\n        \n        # Down\n        for row in range(top, bottom + 1):\n            result.append(matrix[row][right])\n        right -= 1\n        \n        # Left\n        if top <= bottom:\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n        \n        # Up\n        if left <= right:\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n    \n    return result",
        "time_complexity": "O(m Ã n)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "Use boundary management approach. Track four boundaries (top, bottom, left, right) and traverse in spiral order while shrinking boundaries.",
    "hints": [
      "Maintain four boundaries: top, bottom, left, right",
      "Traverse in order: right, down, left, up, and update boundaries",
      "Check boundary conditions before traversing left and up directions"
    ],
    "difficulty_score": 6550,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M073",
    "title": "Bitmask DP: Subset Sum with Small N",
    "slug": "subset-sum-bitmask-dp",
    "difficulty": "Medium",
    "points": 6600,
    "topics": ["Dynamic Programming", "Bitmask", "Bit Manipulation"],
    "tags": ["bitmask-dp", "subset-enumeration", "state-compression", "exponential-optimization", "bit-operations"],
    "statement_markdown": "Master **Bitmask Dynamic Programming for subset problems**:\n\n1. **State Compression**: Use bitmasks to represent subset states efficiently\n2. **Subset Enumeration**: Systematically iterate through all possible subsets\n3. **State Transitions**: Navigate between states using bit operations\n4. **Optimization Techniques**: Prune impossible states and optimize transitions\n5. **Space-Time Tradeoffs**: Balance memory usage with computational efficiency\n\nImplement efficient bitmask DP algorithms for subset sum and related problems.",
    "input_format": "Array of integers and target sum for subset problems",
    "output_format": "Subset existence, subset enumeration, algorithm analysis",
    "constraints": [
      "1 <= n <= 20",
      "1 <= nums[i] <= 1000",
      "1 <= target <= sum(nums)"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def subsetSum(nums, target):\n    n = len(nums)\n    \n    # Bitmask enumeration approach\n    for mask in range(1 << n):\n        subset_sum = 0\n        for i in range(n):\n            if mask & (1 << i):\n                subset_sum += nums[i]\n        \n        if subset_sum == target:\n            return True\n    \n    return False\n\n# Alternative: State compression approach\ndef subsetSum_optimized(nums, target):\n    achievable = {0}\n    \n    for num in nums:\n        new_achievable = set(achievable)\n        for prev_sum in achievable:\n            new_sum = prev_sum + num\n            if new_sum <= target:\n                new_achievable.add(new_sum)\n        achievable = new_achievable\n    \n    return target in achievable",
        "time_complexity": "O(n Ã 2^n)",
        "space_complexity": "O(2^n)"
      }
    },
    "editorial": "Use bitmask to enumerate all possible subsets. For each subset, calculate sum and check if it equals target. Optimize with state compression for larger inputs.",
    "hints": [
      "Use bitmask to represent subset membership efficiently",
      "Enumerate all 2^n possible subsets when n is small",
      "Consider meet-in-the-middle optimization for larger n"
    ],
    "difficulty_score": 6600,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M074",
    "title": "Segment Tree: Range Query Operations",
    "slug": "segment-tree-range-queries",
    "difficulty": "Medium",
    "points": 6650,
    "topics": ["Segment Tree", "Data Structure", "Range Query"],
    "tags": ["segment-tree", "range-queries", "tree-data-structure", "lazy-propagation", "range-updates"],
    "statement_markdown": "Master **Segment Tree for efficient range operations**:\n\n1. **Tree Construction**: Build segment tree from array for O(log n) queries\n2. **Range Queries**: Implement sum, min, max, and custom range operations\n3. **Point Updates**: Modify single elements and update tree efficiently\n4. **Lazy Propagation**: Handle range updates with deferred computation\n5. **Memory Optimization**: Space-efficient implementation techniques\n\nImplement comprehensive segment tree solutions for range query problems.",
    "input_format": "Array for tree construction and query/update operations",
    "output_format": "Query results, update confirmations, tree analysis",
    "constraints": [
      "1 <= n <= 10^5",
      "1 <= queries <= 10^5",
      "-10^9 <= values <= 10^9"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "class SegmentTree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.build(arr, 1, 0, self.n - 1)\n    \n    def build(self, arr, node, start, end):\n        if start == end:\n            self.tree[node] = arr[start]\n        else:\n            mid = (start + end) // 2\n            self.build(arr, 2 * node, start, mid)\n            self.build(arr, 2 * node + 1, mid + 1, end)\n            self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]\n    \n    def query(self, node, start, end, l, r):\n        if r < start or end < l:\n            return 0\n        if l <= start and end <= r:\n            return self.tree[node]\n        \n        mid = (start + end) // 2\n        left_sum = self.query(2 * node, start, mid, l, r)\n        right_sum = self.query(2 * node + 1, mid + 1, end, l, r)\n        return left_sum + right_sum\n    \n    def update(self, node, start, end, idx, val):\n        if start == end:\n            self.tree[node] = val\n        else:\n            mid = (start + end) // 2\n            if idx <= mid:\n                self.update(2 * node, start, mid, idx, val)\n            else:\n                self.update(2 * node + 1, mid + 1, end, idx, val)\n            self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]",
        "time_complexity": "O(log n) per query/update",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Build segment tree recursively by combining child node results. Query by recursively searching relevant ranges. Update by modifying path from root to target leaf.",
    "hints": [
      "Use 4*n space to handle all internal nodes safely",
      "Implement recursive build, query, and update functions",
      "Handle partial range overlaps by splitting queries"
    ],
    "difficulty_score": 6650,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M075",
    "title": "Hash Table: Subarray Sum Equals K",
    "slug": "subarray-sum-equals-k",
    "difficulty": "Medium",
    "points": 6700,
    "topics": ["Hash Table", "Array", "Prefix Sum"],
    "tags": ["prefix-sum", "hash-map", "subarray", "cumulative-sum", "two-sum-variant"],
    "statement_markdown": "Master **Hash table techniques for subarray sum problems**:\n\n1. **Prefix Sum Concept**: Use cumulative sums to represent subarray sums\n2. **Hash Map Optimization**: Store prefix sums for O(1) lookup\n3. **Two Sum Extension**: Apply two-sum logic to subarray problems\n4. **Multiple Solutions**: Count all valid subarrays efficiently\n5. **Edge Case Handling**: Zero sums, negative numbers, duplicates\n\nImplement efficient hash-based solutions for subarray sum problems.",
    "input_format": "Array of integers and target sum k",
    "output_format": "Count of subarrays with sum k, algorithm analysis",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-1000 <= nums[i] <= 1000",
      "-10^7 <= k <= 10^7"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def subarraySum(nums, k):\n    count = 0\n    prefix_sum = 0\n    sum_count = {0: 1}\n    \n    for num in nums:\n        prefix_sum += num\n        \n        if prefix_sum - k in sum_count:\n            count += sum_count[prefix_sum - k]\n        \n        sum_count[prefix_sum] = sum_count.get(prefix_sum, 0) + 1\n    \n    return count",
        "time_complexity": "O(n)",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use hash map to store prefix sum frequencies. For each position, check if (current_sum - k) exists to find subarrays with sum k.",
    "hints": [
      "Use prefix sums to convert subarray sum to difference problem",
      "Store prefix sum frequencies in hash map for O(1) lookup",
      "Initialize hash map with {0: 1} to handle subarrays from start"
    ],
    "difficulty_score": 6700,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M076",
    "title": "Linked List: Copy List with Random Pointer",
    "slug": "copy-list-random-pointer",
    "difficulty": "Medium",
    "points": 6750,
    "topics": ["Linked List", "Hash Table", "Deep Copy"],
    "tags": ["linked-list", "deep-copy", "hash-map", "pointer-manipulation", "graph-cloning"],
    "statement_markdown": "Master **Deep copying of complex linked list structures**:\n\n1. **Hash Map Approach**: Use mapping from original to copied nodes\n2. **Interweaving Method**: Temporarily modify original list structure\n3. **Two-Pass Algorithm**: Separate node creation and pointer assignment\n4. **Space Optimization**: Achieve O(1) extra space with clever techniques\n5. **Edge Case Handling**: Null pointers, cycles, and self-references\n\nImplement efficient algorithms for deep copying linked lists with random pointers.",
    "input_format": "Linked list where each node has next and random pointers",
    "output_format": "Deep copy of the list, algorithm analysis, pointer verification",
    "constraints": [
      "0 <= n <= 1000",
      "-10^4 <= Node.val <= 10^4", 
      "Node.random is null or points to any node in the linked list"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def copyRandomList(head):\n    if not head:\n        return None\n    \n    # HashMap approach\n    original_to_copy = {}\n    \n    # First pass: create all nodes\n    current = head\n    while current:\n        original_to_copy[current] = Node(current.val)\n        current = current.next\n    \n    # Second pass: set pointers\n    current = head\n    while current:\n        copied_node = original_to_copy[current]\n        \n        if current.next:\n            copied_node.next = original_to_copy[current.next]\n        if current.random:\n            copied_node.random = original_to_copy[current.random]\n        \n        current = current.next\n    \n    return original_to_copy[head]",
        "time_complexity": "O(n)",
        "space_complexity": "O(n) for hash map, O(1) for interweaving"
      }
    },
    "editorial": "Use hash map to create mapping from original to copied nodes. First pass creates nodes, second pass sets pointers using the mapping.",
    "hints": [
      "Create mapping from original nodes to copied nodes",
      "Handle next and random pointers separately in two passes", 
      "Consider O(1) space solution by temporarily modifying original list"
    ],
    "difficulty_score": 6750,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M077",
    "title": "Graph Theory: Connected Components in Undirected Graph",
    "slug": "connected-components-undirected-graph",
    "difficulty": "Medium",
    "points": 6800,
    "topics": ["Graph Theory", "Union Find", "DFS", "BFS"],
    "tags": ["connected-components", "graph-traversal", "union-find", "disjoint-set", "graph-connectivity"],
    "statement_markdown": "Master **Connected component analysis in undirected graphs**:\n\n1. **DFS Approach**: Depth-first traversal to explore components\n2. **BFS Method**: Breadth-first search for component discovery\n3. **Union-Find (Disjoint Set)**: Efficient component tracking with path compression\n4. **Component Properties**: Size analysis, largest component identification\n5. **Dynamic Connectivity**: Adding edges and tracking component changes\n\nImplement efficient algorithms for counting and analyzing connected components.",
    "input_format": "Graph represented as adjacency list or edge list",
    "output_format": "Number of connected components, component analysis, traversal details",
    "constraints": [
      "1 <= n <= 2000",
      "0 <= edges.length <= 3000",
      "edges[i].length == 2",
      "0 <= ai, bi < n",
      "ai != bi",
      "No duplicate edges"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def countComponents(n, edges):\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    visited = [False] * n\n    count = 0\n    \n    def dfs(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n    \n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            count += 1\n    \n    return count",
        "time_complexity": "O(V + E)",
        "space_complexity": "O(V + E) for adjacency list"
      }
    },
    "editorial": "Build adjacency list and use DFS/BFS to traverse each component. Alternative: Use Union-Find for dynamic connectivity queries.",
    "hints": [
      "Build adjacency list representation of the graph",
      "Use DFS or BFS to explore each connected component",
      "Alternative: Union-Find data structure for efficient queries"
    ],
    "difficulty_score": 6800,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M078",
    "title": "Graph Theory: Alien Dictionary - Topological Sort",
    "slug": "alien-dictionary-topological-sort",
    "difficulty": "Medium", 
    "points": 6850,
    "topics": ["Topological Sort", "Graph Theory", "String Processing"],
    "tags": ["topological-sort", "dfs", "bfs", "alien-language", "character-ordering", "dependency-graph"],
    "statement_markdown": "Master **Topological sorting for character order determination**:\n\n1. **Graph Construction**: Build directed graph from word comparisons\n2. **Kahn's Algorithm**: BFS-based topological sort with in-degree tracking\n3. **DFS Approach**: Depth-first search with post-order traversal\n4. **Cycle Detection**: Identify impossible orderings in alien language\n5. **Character Dependencies**: Analyze precedence relationships between characters\n\nImplement efficient algorithms for determining character order in alien dictionaries.",
    "input_format": "Array of words in alien dictionary order",
    "output_format": "Valid character ordering, topological sort analysis, cycle detection",
    "constraints": [
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 20",
      "words[i] consists of lowercase English letters only",
      "It's guaranteed that words are sorted lexicographically by the alien language"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def alienOrder(words):\n    chars = set()\n    for word in words:\n        chars.update(word)\n    \n    graph = defaultdict(set)\n    in_degree = {c: 0 for c in chars}\n    \n    for i in range(len(words) - 1):\n        word1, word2 = words[i], words[i + 1]\n        min_len = min(len(word1), len(word2))\n        \n        for j in range(min_len):\n            if word1[j] != word2[j]:\n                if word2[j] not in graph[word1[j]]:\n                    graph[word1[j]].add(word2[j])\n                    in_degree[word2[j]] += 1\n                break\n        else:\n            if len(word1) > len(word2):\n                return \"\"\n    \n    queue = deque([c for c in chars if in_degree[c] == 0])\n    result = []\n    \n    while queue:\n        char = queue.popleft()\n        result.append(char)\n        \n        for neighbor in graph[char]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return ''.join(result) if len(result) == len(chars) else \"\"",
        "time_complexity": "O(C + N*M)",
        "space_complexity": "O(C) for graph storage"
      }
    },
    "editorial": "Compare adjacent words to build directed graph of character dependencies, then use topological sort to find valid ordering.",
    "hints": [
      "Compare adjacent words to find character precedence relationships",
      "Build directed graph where edge aâb means a comes before b",
      "Use topological sort (Kahn's algorithm or DFS) to find valid ordering"
    ],
    "difficulty_score": 6850,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M079",
    "title": "Data Structures: Next Greater Element - Monotonic Stack",
    "slug": "next-greater-element-monotonic-stack",
    "difficulty": "Medium",
    "points": 6900,
    "topics": ["Monotonic Stack", "Array Processing", "Stack"],
    "tags": ["monotonic-stack", "next-greater-element", "stack-operations", "array-traversal", "optimization"],
    "statement_markdown": "Master **Monotonic stack for next greater element problems**:\n\n1. **Basic Next Greater Element**: Find next larger element for each array element\n2. **Circular Array Variant**: Handle wraparound using array duplication concept\n3. **Next Greater Element II**: Different array context with element mapping\n4. **Monotonic Stack Properties**: Maintain decreasing/increasing order for efficiency\n5. **Optimization Techniques**: Single-pass solutions with O(n) time complexity\n\nImplement efficient algorithms using monotonic stack for various next greater element scenarios.",
    "input_format": "Array of integers, element queries, circular array indicators",
    "output_format": "Next greater elements array, stack analysis, complexity breakdown",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "All integers in nums are unique",
      "1 <= queries.length <= 10^4"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def nextGreaterElement(nums):\n    n = len(nums)\n    result = [-1] * n\n    stack = []\n    \n    for i in range(n):\n        while stack and nums[i] > nums[stack[-1]]:\n            idx = stack.pop()\n            result[idx] = nums[i]\n        stack.append(i)\n    \n    return result",
        "time_complexity": "O(n)",
        "space_complexity": "O(n) for stack storage"
      }
    },
    "editorial": "Use monotonic decreasing stack to track potential next greater elements. Each element is pushed and popped at most once, ensuring O(n) time complexity.",
    "hints": [
      "Use stack to maintain potential candidates for next greater element",
      "Maintain monotonic decreasing order in stack for efficiency",
      "Store indices in stack rather than values for position tracking"
    ],
    "difficulty_score": 6900,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M080",
    "title": "Data Structures: Find Median from Data Stream - Two Heaps",
    "slug": "find-median-data-stream-two-heaps",
    "difficulty": "Medium",
    "points": 6950,
    "topics": ["Heap", "Data Stream", "Design"],
    "tags": ["median-finding", "two-heaps", "max-heap", "min-heap", "data-stream", "real-time-processing"],
    "statement_markdown": "Master **Median calculation in streaming data using dual heap approach**:\n\n1. **Two Heap Strategy**: Max heap for smaller half, min heap for larger half\n2. **Balance Maintenance**: Keep heap sizes differing by at most 1\n3. **Efficient Insertion**: O(log n) insertion with heap rebalancing\n4. **Median Extraction**: O(1) median calculation from heap tops\n5. **Dynamic Data Stream**: Handle continuous data arrival efficiently\n\nImplement efficient algorithms for real-time median calculation in streaming data scenarios.",
    "input_format": "Stream of integers, insertion and median query operations",
    "output_format": "Median values after each operation, heap analysis, complexity breakdown",
    "constraints": [
      "-10^5 <= num <= 10^5",
      "At most 5 * 10^4 calls to addNum and findMedian",
      "There will be at least one element before calling findMedian"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.small = []  # Max heap\n        self.large = []  # Min heap\n    \n    def addNum(self, num):\n        heapq.heappush(self.small, -num)\n        \n        if self.small and self.large and (-self.small[0] > self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        \n        if len(self.small) > len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        \n        if len(self.large) > len(self.small) + 1:\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n    \n    def findMedian(self):\n        if len(self.small) > len(self.large):\n            return float(-self.small[0])\n        elif len(self.large) > len(self.small):\n            return float(self.large[0])\n        else:\n            return (-self.small[0] + self.large[0]) / 2.0",
        "time_complexity": "O(log n) for addNum, O(1) for findMedian",
        "space_complexity": "O(n) for storing all elements"
      }
    },
    "editorial": "Use two heaps: max heap for smaller half, min heap for larger half. Maintain size balance and extract median from heap tops in O(1) time.",
    "hints": [
      "Use two heaps: max heap for smaller values, min heap for larger values",
      "Maintain invariant: heap sizes differ by at most 1",
      "Median is either one heap's top or average of both tops"
    ],
    "difficulty_score": 6950,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M081",
    "title": "Binary Search: Search in Rotated Sorted Array",
    "slug": "search-in-rotated-sorted-array",
    "difficulty": "Medium",
    "points": 7000,
    "topics": ["Binary Search", "Array", "Divide and Conquer"],
    "tags": ["binary-search", "rotated-array", "pivot-finding", "modified-binary-search", "logarithmic-search"],
    "statement_markdown": "Master **Binary search in rotated sorted arrays**:\n\n1. **Pivot Detection**: Identify rotation point in sorted array\n2. **Modified Binary Search**: Adapt binary search for rotated structure\n3. **Range Analysis**: Determine which half contains target element\n4. **Edge Case Handling**: Single elements, no rotation, duplicates\n5. **Optimization Techniques**: Single-pass O(log n) search algorithms\n\nImplement efficient search algorithms for rotated sorted arrays maintaining logarithmic complexity.",
    "input_format": "Rotated sorted array and target value",
    "output_format": "Target index or -1, search analysis, complexity verification",
    "constraints": [
      "1 <= nums.length <= 5000",
      "-10^4 <= nums[i] <= 10^4",
      "All values in nums are unique",
      "-10^4 <= target <= 10^4"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == target:\n            return mid\n        \n        if nums[left] <= nums[mid]:  # Left half sorted\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:  # Right half sorted\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return -1",
        "time_complexity": "O(log n)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "Identify which half of the array is sorted at each step, then check if target lies within that sorted range to determine search direction.",
    "hints": [
      "At least one half of the rotated array is always sorted",
      "Determine which half is sorted by comparing left, mid, and right elements",
      "Check if target lies within the sorted half's range"
    ],
    "difficulty_score": 7000,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M082",
    "title": "Two Pointers: 3Sum Closest - Optimized Triplet Search",
    "slug": "3sum-closest-two-pointers",
    "difficulty": "Medium",
    "points": 7050,
    "topics": ["Two Pointers", "Array", "Sorting"],
    "tags": ["two-pointers", "3sum", "triplet-sum", "closest-target", "array-optimization"],
    "statement_markdown": "Master **Optimized triplet sum finding with two pointers**:\n\n1. **3Sum Closest**: Find triplet with sum closest to target value\n2. **Two Pointer Optimization**: Reduce O(nÂ³) brute force to O(nÂ²)\n3. **Sorting Strategy**: Enable efficient duplicate skipping and convergence\n4. **Distance Minimization**: Track minimum absolute difference from target\n5. **Early Termination**: Optimize with exact match detection and bounds checking\n\nImplement efficient algorithms for finding optimal triplet sums using two-pointer technique.",
    "input_format": "Array of integers and target sum value",
    "output_format": "Closest triplet sum, analysis of search process, optimization details",
    "constraints": [
      "3 <= nums.length <= 1000",
      "-1000 <= nums[i] <= 1000",
      "-10^4 <= target <= 10^4"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def threeSumClosest(nums, target):\n    nums.sort()\n    n = len(nums)\n    closest_sum = float('inf')\n    \n    for i in range(n - 2):\n        left, right = i + 1, n - 1\n        \n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if abs(current_sum - target) < abs(closest_sum - target):\n                closest_sum = current_sum\n            \n            if current_sum == target:\n                return current_sum\n            elif current_sum < target:\n                left += 1\n            else:\n                right -= 1\n    \n    return closest_sum",
        "time_complexity": "O(nÂ²)",
        "space_complexity": "O(1) auxiliary space"
      }
    },
    "editorial": "Sort array and use two pointers for each fixed element. Compare current sum with target and adjust pointers accordingly while tracking closest sum.",
    "hints": [
      "Sort the array first to enable two-pointer technique",
      "For each fixed element, use two pointers to find optimal pair",
      "Track the sum with minimum absolute difference from target"
    ],
    "difficulty_score": 7050,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M083",
    "title": "Sliding Window: Minimum Window Substring",
    "slug": "minimum-window-substring",
    "difficulty": "Medium",
    "points": 7100,
    "topics": ["Sliding Window", "Hash Table", "String"],
    "tags": ["sliding-window", "two-pointers", "hash-map", "string-matching", "window-optimization"],
    "statement_markdown": "Master **Sliding window technique for substring matching**:\n\n1. **Variable Window**: Expandable and contractible window based on conditions\n2. **Character Frequency**: Track required vs current character counts\n3. **Window Validation**: Efficient checking if window contains all required characters\n4. **Optimization**: Minimize window size while maintaining validity\n5. **Hash Map Management**: Efficient frequency tracking and comparison\n\nImplement efficient algorithms for finding minimum window containing all required characters.",
    "input_format": "Source string and target pattern string",
    "output_format": "Minimum window substring, analysis of sliding process, optimization details",
    "constraints": [
      "1 <= s.length, t.length <= 10^5",
      "s and t consist of uppercase and lowercase English letters",
      "It's guaranteed that the answer is unique"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def minWindow(s, t):\n    if not s or not t:\n        return \"\"\n    \n    target_freq = {}\n    for char in t:\n        target_freq[char] = target_freq.get(char, 0) + 1\n    \n    required_chars = len(target_freq)\n    formed_chars = 0\n    window_freq = {}\n    \n    left = 0\n    min_len = float('inf')\n    min_left = 0\n    \n    for right in range(len(s)):\n        char = s[right]\n        window_freq[char] = window_freq.get(char, 0) + 1\n        \n        if char in target_freq and window_freq[char] == target_freq[char]:\n            formed_chars += 1\n        \n        while formed_chars == required_chars:\n            if right - left + 1 < min_len:\n                min_len = right - left + 1\n                min_left = left\n            \n            left_char = s[left]\n            window_freq[left_char] -= 1\n            \n            if left_char in target_freq and window_freq[left_char] < target_freq[left_char]:\n                formed_chars -= 1\n            \n            left += 1\n    \n    return \"\" if min_len == float('inf') else s[min_left:min_left + min_len]",
        "time_complexity": "O(|s| + |t|)",
        "space_complexity": "O(|s| + |t|) for hash maps"
      }
    },
    "editorial": "Use sliding window with character frequency tracking. Expand window until valid, then contract while maintaining validity to minimize window size.",
    "hints": [
      "Use sliding window technique with two pointers",
      "Track character frequencies with hash maps",
      "Expand window until valid, then contract to minimize size"
    ],
    "difficulty_score": 7100,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M084",
    "title": "Graph Traversal: Number of Islands - DFS/BFS Grid Search",
    "slug": "number-of-islands-dfs-bfs",
    "difficulty": "Medium",
    "points": 7150,
    "topics": ["DFS", "BFS", "Grid Traversal", "Connected Components"],
    "tags": ["dfs", "bfs", "grid-search", "islands", "connected-components", "matrix-traversal"],
    "statement_markdown": "Master **Grid-based connected component analysis**:\n\n1. **DFS Island Detection**: Depth-first search for connected land masses\n2. **BFS Alternative**: Breadth-first exploration of island boundaries\n3. **Grid Traversal**: 4-directional movement and boundary checking\n4. **Visited Tracking**: Efficient marking to avoid revisiting cells\n5. **Union-Find Approach**: Disjoint set for dynamic connectivity\n\nImplement efficient algorithms for counting connected components in 2D grids.",
    "input_format": "2D binary grid where 1 represents land and 0 represents water",
    "output_format": "Number of islands, traversal analysis, algorithm comparison",
    "constraints": [
      "1 <= grid.length <= 300",
      "1 <= grid[i].length <= 300",
      "grid[i][j] is '0' or '1'"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def numIslands(grid):\n    if not grid or not grid[0]:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    island_count = 0\n    \n    def dfs(r, c):\n        if (r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != '1'):\n            return\n        \n        grid[r][c] = '0'  # Mark as visited\n        \n        # Explore 4 directions\n        dfs(r + 1, c)\n        dfs(r - 1, c)\n        dfs(r, c + 1)\n        dfs(r, c - 1)\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] == '1':\n                dfs(i, j)\n                island_count += 1\n    \n    return island_count",
        "time_complexity": "O(M Ã N)",
        "space_complexity": "O(min(M, N)) for recursion stack"
      }
    },
    "editorial": "Use DFS or BFS to explore connected land cells. For each unvisited land cell, traverse entire island and increment count.",
    "hints": [
      "Use DFS or BFS to explore connected components",
      "Mark visited cells to avoid counting same island multiple times",
      "Consider 4-directional movement only (no diagonals)"
    ],
    "difficulty_score": 7150,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M085",
    "title": "Dynamic Programming: Longest Increasing Subsequence",
    "slug": "longest-increasing-subsequence",
    "difficulty": "Medium",
    "points": 7200,
    "topics": ["Dynamic Programming", "Binary Search", "Greedy"],
    "tags": ["lis", "dynamic-programming", "binary-search", "subsequence", "patience-sorting"],
    "statement_markdown": "Master **Longest Increasing Subsequence (LIS) algorithms**:\n\n1. **DP O(nÂ²) Solution**: Classic dynamic programming approach\n2. **Binary Search O(n log n)**: Optimized solution using patience sorting\n3. **Greedy Strategy**: Maintain smallest tail for each length\n4. **Path Reconstruction**: Track actual LIS sequence\n5. **Variants**: Strictly vs non-strictly increasing, longest decreasing\n\nImplement efficient algorithms for finding longest increasing subsequences with optimal complexity.",
    "input_format": "Array of integers",
    "output_format": "Length of LIS, actual subsequence, algorithm analysis",
    "constraints": [
      "1 <= nums.length <= 2500",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "import bisect\n\ndef lengthOfLIS(nums):\n    if not nums:\n        return 0\n    \n    tails = []\n    \n    for num in nums:\n        pos = bisect.bisect_left(tails, num)\n        \n        if pos == len(tails):\n            tails.append(num)\n        else:\n            tails[pos] = num\n    \n    return len(tails)",
        "time_complexity": "O(n log n)",
        "space_complexity": "O(n) for tails array"
      }
    },
    "editorial": "Use binary search with patience sorting algorithm. Maintain array of smallest tail elements for each LIS length, updating via binary search.",
    "hints": [
      "Consider DP approach: dp[i] = length of LIS ending at index i",
      "For optimal solution, use binary search with patience sorting",
      "Maintain smallest possible tail for each LIS length"
    ],
    "difficulty_score": 7200,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M086",
    "title": "Data Structures: Merge K Sorted Lists - Heap & Divide Conquer",
    "slug": "merge-k-sorted-lists",
    "difficulty": "Medium",
    "points": 7250,
    "topics": ["Heap", "Divide and Conquer", "Linked List", "Merge Sort"],
    "tags": ["min-heap", "priority-queue", "divide-conquer", "merge-sort", "k-way-merge"],
    "statement_markdown": "Master **Efficient merging of multiple sorted sequences**:\n\n1. **Min-Heap Approach**: Priority queue for k-way merge\n2. **Divide and Conquer**: Recursive pairing and merging\n3. **Sequential Merging**: Iterative two-list merging\n4. **Space Optimization**: In-place vs auxiliary space trade-offs\n5. **Performance Analysis**: Time complexity optimization strategies\n\nImplement efficient algorithms for merging k sorted linked lists with optimal performance.",
    "input_format": "Array of k sorted linked lists",
    "output_format": "Single merged sorted linked list, complexity analysis",
    "constraints": [
      "k == lists.length",
      "0 <= k <= 10^4",
      "0 <= lists[i].length <= 500",
      "-10^4 <= lists[i][j] <= 10^4",
      "lists[i] is sorted in ascending order",
      "The sum of lists[i].length won't exceed 10^4"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "import heapq\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n    \n    def __lt__(self, other):\n        return self.val < other.val\n\ndef mergeKLists(lists):\n    heap = []\n    \n    for i, head in enumerate(lists):\n        if head:\n            heapq.heappush(heap, (head.val, i, head))\n    \n    dummy = ListNode(0)\n    current = dummy\n    \n    while heap:\n        val, list_idx, node = heapq.heappop(heap)\n        current.next = node\n        current = current.next\n        \n        if node.next:\n            heapq.heappush(heap, (node.next.val, list_idx, node.next))\n    \n    return dummy.next",
        "time_complexity": "O(N log k)",
        "space_complexity": "O(k) for heap"
      }
    },
    "editorial": "Use min-heap to efficiently find minimum among k list heads, or divide-and-conquer to pair and merge lists recursively.",
    "hints": [
      "Use min-heap to track minimum element among k list heads",
      "Alternative: divide-and-conquer with pairwise merging",
      "Each approach gives O(N log k) time complexity"
    ],
    "difficulty_score": 7250,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M087",
    "title": "Graph Algorithm: Course Schedule - Topological Sort & Cycle Detection",
    "slug": "course-schedule-topological-sort",
    "difficulty": "Medium",
    "points": 7300,
    "topics": ["Graph", "DFS", "BFS", "Topological Sort"],
    "tags": ["course-schedule", "topological-sort", "cycle-detection", "dfs", "kahns-algorithm"],
    "statement_markdown": "Master **Graph cycle detection and topological ordering**:\n\n1. **DFS Cycle Detection**: Use three-color approach (white, gray, black)\n2. **Kahn's Algorithm**: BFS-based topological sort with in-degrees\n3. **Course Dependencies**: Model prerequisites as directed graph\n4. **Cycle Implications**: Impossible to complete if cycle exists\n5. **Multiple Solutions**: Both DFS and BFS approaches\n\nImplement efficient algorithms for detecting cycles and generating valid course orderings.",
    "input_format": "Number of courses and prerequisite pairs",
    "output_format": "Boolean feasibility, course ordering, cycle detection analysis",
    "constraints": [
      "1 <= numCourses <= 10^5",
      "0 <= prerequisites.length <= 5000",
      "prerequisites[i].length == 2",
      "0 <= ai, bi < numCourses",
      "All prerequisite pairs are unique"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def canFinish(numCourses, prerequisites):\n    graph = [[] for _ in range(numCourses)]\n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n    \n    WHITE, GRAY, BLACK = 0, 1, 2\n    color = [WHITE] * numCourses\n    \n    def hasCycle(node):\n        if color[node] == GRAY:\n            return True\n        if color[node] == BLACK:\n            return False\n        \n        color[node] = GRAY\n        for neighbor in graph[node]:\n            if hasCycle(neighbor):\n                return True\n        color[node] = BLACK\n        return False\n    \n    for i in range(numCourses):\n        if hasCycle(i):\n            return False\n    return True",
        "time_complexity": "O(V + E)",
        "space_complexity": "O(V + E)"
      }
    },
    "editorial": "Use DFS with three-color marking or Kahn's algorithm with in-degree counting to detect cycles in directed graph.",
    "hints": [
      "Model prerequisites as directed graph edges",
      "Use DFS with three colors: white (unvisited), gray (processing), black (finished)",
      "Alternative: Kahn's algorithm with BFS and in-degree tracking"
    ],
    "difficulty_score": 7300,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M088",
    "title": "Data Structure: Design Add & Search Words - Trie with Wildcards",
    "slug": "design-add-search-words-trie",
    "difficulty": "Medium",
    "points": 7350,
    "topics": ["Trie", "DFS", "Design"],
    "tags": ["trie", "prefix-tree", "wildcard-search", "dfs", "design-data-structure"],
    "statement_markdown": "Master **Trie data structure with wildcard search capability**:\n\n1. **Trie Construction**: Build prefix tree for efficient word storage\n2. **Wildcard Matching**: Handle '.' character matching any letter\n3. **DFS Search**: Recursive traversal for pattern matching\n4. **Memory Optimization**: Efficient node representation\n5. **Edge Case Handling**: Empty strings, special characters\n\nImplement efficient trie-based data structure supporting add and wildcard search operations.",
    "input_format": "Sequence of addWord and search operations",
    "output_format": "Boolean search results, trie structure analysis",
    "constraints": [
      "1 <= word.length <= 25",
      "word in addWord consists of lowercase English letters",
      "word in search consists of '.' or lowercase English letters",
      "At most 10^4 calls to addWord and search"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "class WordDictionary:\n    def __init__(self):\n        self.trie = {}\n    \n    def addWord(self, word):\n        node = self.trie\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n    \n    def search(self, word):\n        def dfs(node, i):\n            if i == len(word):\n                return '$' in node\n            \n            char = word[i]\n            if char == '.':\n                for key in node:\n                    if key != '$' and dfs(node[key], i + 1):\n                        return True\n                return False\n            else:\n                if char in node:\n                    return dfs(node[char], i + 1)\n                return False\n        \n        return dfs(self.trie, 0)",
        "time_complexity": "O(M) for add, O(N*26^M) for search worst case",
        "space_complexity": "O(ALPHABET_SIZE * N * M)"
      }
    },
    "editorial": "Use trie for word storage. Implement DFS with backtracking for wildcard search, exploring all possible paths for '.' characters.",
    "hints": [
      "Build trie with nested dictionaries, use special marker for word endings",
      "For search, use DFS: exact match for letters, explore all branches for '.'",
      "Recursively traverse trie matching pattern character by character"
    ],
    "difficulty_score": 7350,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M089",
    "title": "Backtracking: Combination Sum - Generate All Valid Combinations",
    "slug": "combination-sum-backtracking",
    "difficulty": "Medium",
    "points": 7400,
    "topics": ["Backtracking", "Array", "Recursion"],
    "tags": ["combination-sum", "backtracking", "recursion", "duplicate-handling", "pruning"],
    "statement_markdown": "Master **Backtracking for combination generation**:\n\n1. **Basic Combination Sum**: Numbers can be reused unlimited times\n2. **Combination Sum II**: Each number used at most once\n3. **Pruning Optimization**: Early termination when target exceeded\n4. **Duplicate Handling**: Avoid duplicate combinations\n5. **Space Optimization**: Efficient recursive implementation\n\nImplement efficient backtracking algorithms for generating all valid number combinations.",
    "input_format": "Array of candidates and target sum",
    "output_format": "List of all unique combinations, algorithm analysis",
    "constraints": [
      "1 <= candidates.length <= 30",
      "2 <= candidates[i] <= 40",
      "All elements of candidates are distinct",
      "1 <= target <= 40"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def combinationSum(candidates, target):\n    result = []\n    \n    def backtrack(start, current, remaining):\n        if remaining == 0:\n            result.append(current[:])\n            return\n        \n        for i in range(start, len(candidates)):\n            if candidates[i] <= remaining:\n                current.append(candidates[i])\n                backtrack(i, current, remaining - candidates[i])\n                current.pop()\n    \n    backtrack(0, [], target)\n    return result",
        "time_complexity": "O(N^(T/M)) where T=target, M=minimal candidate",
        "space_complexity": "O(T/M) for recursion depth"
      }
    },
    "editorial": "Use backtracking with recursion. Include/exclude each candidate, allowing reuse. Prune when current sum exceeds target.",
    "hints": [
      "Use backtracking: for each position, try all valid candidates",
      "Allow reusing same candidate by not incrementing start index",
      "Prune early when current sum exceeds target"
    ],
    "difficulty_score": 7400,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M090",
    "title": "Union-Find: Accounts Merge - Connected Components",
    "slug": "accounts-merge-union-find",
    "difficulty": "Medium",
    "points": 7450,
    "topics": ["Union-Find", "DFS", "Graph"],
    "tags": ["accounts-merge", "union-find", "disjoint-set", "connected-components", "email-grouping"],
    "statement_markdown": "Master **Union-Find for grouping connected accounts**:\n\n1. **Union-Find Structure**: Efficiently merge accounts with shared emails\n2. **Path Compression**: Optimize find operations\n3. **Union by Rank**: Balance tree depth during merges\n4. **Email Mapping**: Track which emails belong to which accounts\n5. **Result Construction**: Build final grouped account lists\n\nImplement efficient Union-Find data structure for merging accounts with common emails.",
    "input_format": "List of accounts, each with name and email list",
    "output_format": "Merged accounts with sorted emails, algorithm analysis",
    "constraints": [
      "1 <= accounts.length <= 1000",
      "2 <= accounts[i].length <= 10",
      "1 <= accounts[i][j].length <= 30",
      "accounts[i][0] is the name",
      "accounts[i][j] for j > 0 is an email"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def accountsMerge(accounts):\n    from collections import defaultdict\n    \n    parent = list(range(len(accounts)))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px != py:\n            parent[px] = py\n    \n    email_to_id = {}\n    for i, account in enumerate(accounts):\n        for email in account[1:]:\n            if email in email_to_id:\n                union(i, email_to_id[email])\n            else:\n                email_to_id[email] = i\n    \n    merged = defaultdict(set)\n    for email, i in email_to_id.items():\n        merged[find(i)].add(email)\n    \n    return [[accounts[i][0]] + sorted(emails) for i, emails in merged.items()]",
        "time_complexity": "O(N * M * Î±(N)) where Î± is inverse Ackermann",
        "space_complexity": "O(N * M)"
      }
    },
    "editorial": "Use Union-Find to group accounts. Map emails to account indices, union accounts sharing emails, then reconstruct merged results.",
    "hints": [
      "Map each email to the first account index containing it",
      "Use Union-Find to merge accounts sharing common emails",
      "Group emails by root parent and reconstruct account lists"
    ],
    "difficulty_score": 7450,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M091",
    "title": "Greedy Algorithm: Gas Station - Circular Journey Optimization",
    "slug": "gas-station-circular-journey",
    "difficulty": "Medium",
    "points": 7500,
    "topics": ["Greedy", "Array"],
    "tags": ["gas-station", "greedy", "circular-array", "optimization", "kadane-variant"],
    "statement_markdown": "Master **Greedy algorithms for circular journey problems**:\n\n1. **Single Pass Solution**: Determine if complete circular trip is possible\n2. **Starting Point Optimization**: Find optimal starting gas station\n3. **Balance Tracking**: Monitor fuel surplus/deficit throughout journey\n4. **Greedy Strategy**: Choose starting point that maximizes success probability\n5. **Edge Case Handling**: Insufficient total fuel, optimal positioning\n\nImplement efficient greedy algorithms for circular traversal optimization problems.",
    "input_format": "Arrays of gas amounts and costs for circular stations",
    "output_format": "Starting station index or -1 if impossible, analysis",
    "constraints": [
      "1 <= gas.length == cost.length <= 10^5",
      "0 <= gas[i], cost[i] <= 10^4",
      "Sum of gas may be less than sum of cost"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def canCompleteCircuit(gas, cost):\n    total_tank = 0\n    current_tank = 0\n    starting_station = 0\n    \n    for i in range(len(gas)):\n        total_tank += gas[i] - cost[i]\n        current_tank += gas[i] - cost[i]\n        \n        if current_tank < 0:\n            starting_station = i + 1\n            current_tank = 0\n    \n    return starting_station if total_tank >= 0 else -1",
        "time_complexity": "O(n)",
        "space_complexity": "O(1)"
      }
    },
    "editorial": "Use greedy approach: if total gas >= total cost, solution exists. Track current balance and reset starting point when balance goes negative.",
    "hints": [
      "Check if total gas >= total cost for feasibility",
      "Use greedy strategy: reset starting point when fuel runs out",
      "Single pass solution with balance tracking"
    ],
    "difficulty_score": 7500,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M092",
    "title": "Matrix Algorithm: Spiral Matrix - Layer-by-Layer Traversal",
    "slug": "spiral-matrix-traversal",
    "difficulty": "Medium",
    "points": 7550,
    "topics": ["Matrix", "Simulation"],
    "tags": ["spiral-matrix", "matrix-traversal", "simulation", "boundary-tracking", "direction-change"],
    "statement_markdown": "Master **Matrix spiral traversal algorithms**:\n\n1. **Layer-by-Layer Approach**: Process matrix in concentric layers\n2. **Direction Simulation**: Track rightâdownâleftâup movement pattern\n3. **Boundary Management**: Handle shrinking boundaries dynamically\n4. **Edge Case Handling**: Single row, single column, empty matrices\n5. **Space Optimization**: In-place traversal without extra storage\n\nImplement efficient algorithms for spiral matrix traversal and construction.",
    "input_format": "2D matrix or dimensions for spiral construction",
    "output_format": "Spiral order array, traversal analysis, boundary tracking",
    "constraints": [
      "1 <= matrix.length, matrix[i].length <= 20",
      "Matrix elements are integers",
      "Matrix may be rectangular (m x n)"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def spiralOrder(matrix):\n    if not matrix:\n        return []\n    \n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    \n    while top <= bottom and left <= right:\n        # Right\n        for col in range(left, right + 1):\n            result.append(matrix[top][col])\n        top += 1\n        \n        # Down\n        for row in range(top, bottom + 1):\n            result.append(matrix[row][right])\n        right -= 1\n        \n        # Left\n        if top <= bottom:\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n        \n        # Up\n        if left <= right:\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n    \n    return result",
        "time_complexity": "O(m * n)",
        "space_complexity": "O(1) excluding output array"
      }
    },
    "editorial": "Use layer-by-layer approach with four pointers (top, bottom, left, right). Process each direction and shrink boundaries.",
    "hints": [
      "Track four boundaries: top, bottom, left, right",
      "Process in order: right â down â left â up",
      "Shrink boundaries after completing each direction"
    ],
    "difficulty_score": 7550,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M093",
    "title": "Bitmask DP: Subset Sum - Exponential State Compression",
    "slug": "subset-sum-bitmask-dp",
    "difficulty": "Medium",
    "points": 7600,
    "topics": ["Bitmask DP", "Dynamic Programming", "Bit Manipulation"],
    "tags": ["subset-sum", "bitmask-dp", "bit-manipulation", "exponential-optimization", "state-compression"],
    "statement_markdown": "Master **Bitmask Dynamic Programming for subset problems**:\n\n1. **State Compression**: Use bitmasks to represent subset selections\n2. **Exponential DP**: Handle 2^n states efficiently with bit operations\n3. **Transition Optimization**: Fast subset enumeration and updates\n4. **Memory Management**: Balance time vs space with small n constraints\n5. **Bit Tricks**: Leverage bitwise operations for performance gains\n\nImplement efficient bitmask DP for subset sum and related combinatorial problems.",
    "input_format": "Array of integers and target sum (small n <= 20)",
    "output_format": "Boolean feasibility, subset analysis, bitmask representation",
    "constraints": [
      "1 <= nums.length <= 20",
      "1 <= nums[i] <= 1000",
      "1 <= target <= 1000",
      "All elements are positive integers"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def canPartition(nums, target):\n    n = len(nums)\n    dp = [set() for _ in range(1 << n)]\n    dp[0].add(0)\n    \n    for mask in range(1 << n):\n        for i in range(n):\n            if mask & (1 << i):\n                prev_mask = mask ^ (1 << i)\n                for sum_val in dp[prev_mask]:\n                    dp[mask].add(sum_val + nums[i])\n    \n    for mask in range(1 << n):\n        if target in dp[mask]:\n            return True\n    return False",
        "time_complexity": "O(2^n * target)",
        "space_complexity": "O(2^n * target)"
      }
    },
    "editorial": "Use bitmask DP where dp[mask] stores all possible sums for subset represented by mask. Iterate through all subsets and their transitions.",
    "hints": [
      "Use bitmasks to represent all possible subsets (2^n states)",
      "For each mask, track all possible sums achievable",
      "Transition: add current element to all sums from previous mask"
    ],
    "difficulty_score": 7600,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M094",
    "title": "Segment Tree: Range Sum Query - Efficient Updates & Queries",
    "slug": "range-sum-query-segment-tree",
    "difficulty": "Medium",
    "points": 7650,
    "topics": ["Segment Tree", "Data Structure Design"],
    "tags": ["segment-tree", "range-query", "point-update", "lazy-propagation", "tree-construction"],
    "statement_markdown": "Master **Segment Tree data structure for range operations**:\n\n1. **Tree Construction**: Build segment tree with O(n) preprocessing\n2. **Point Updates**: Modify single elements in O(log n) time\n3. **Range Queries**: Sum/min/max queries in O(log n) time\n4. **Lazy Propagation**: Efficient range updates with deferred computation\n5. **Space Optimization**: Memory-efficient implementation techniques\n\nImplement efficient segment tree for dynamic range sum queries with updates.",
    "input_format": "Initial array and sequence of update/query operations",
    "output_format": "Query results, tree structure analysis, operation complexity",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4",
      "1 <= operations <= 10^4",
      "0 <= query_left <= query_right < nums.length"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "class NumArray:\n    def __init__(self, nums):\n        self.n = len(nums)\n        self.tree = [0] * (4 * self.n)\n        self.build(nums, 0, 0, self.n - 1)\n    \n    def build(self, nums, node, start, end):\n        if start == end:\n            self.tree[node] = nums[start]\n        else:\n            mid = (start + end) // 2\n            self.build(nums, 2 * node + 1, start, mid)\n            self.build(nums, 2 * node + 2, mid + 1, end)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n    \n    def update(self, index, val):\n        self.update_helper(0, 0, self.n - 1, index, val)\n    \n    def update_helper(self, node, start, end, idx, val):\n        if start == end:\n            self.tree[node] = val\n        else:\n            mid = (start + end) // 2\n            if idx <= mid:\n                self.update_helper(2 * node + 1, start, mid, idx, val)\n            else:\n                self.update_helper(2 * node + 2, mid + 1, end, idx, val)\n            self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2]\n    \n    def sumRange(self, left, right):\n        return self.query(0, 0, self.n - 1, left, right)\n    \n    def query(self, node, start, end, l, r):\n        if r < start or end < l:\n            return 0\n        if l <= start and end <= r:\n            return self.tree[node]\n        mid = (start + end) // 2\n        return self.query(2 * node + 1, start, mid, l, r) + self.query(2 * node + 2, mid + 1, end, l, r)",
        "time_complexity": "O(log n) per operation",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Build segment tree with O(n) construction. Support O(log n) point updates and range queries using tree traversal.",
    "hints": [
      "Build complete binary tree with 4*n nodes for safety",
      "Recursively build tree: leaf nodes are array elements",
      "Update: traverse path to leaf, query: combine overlapping ranges"
    ],
    "difficulty_score": 7650,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M095",
    "title": "Hash Map: Subarray Sum Equals K - Prefix Sum Optimization",
    "slug": "subarray-sum-equals-k",
    "difficulty": "Medium",
    "points": 7700,
    "topics": ["Hash Map", "Prefix Sum", "Array"],
    "tags": ["subarray-sum", "prefix-sum", "hash-map", "cumulative-sum", "two-sum-variant"],
    "statement_markdown": "Master **Prefix sum with hash map optimization for subarray problems**:\n\n1. **Prefix Sum Technique**: Convert subarray sum to difference of prefix sums\n2. **Hash Map Optimization**: O(1) lookup for target differences\n3. **Count Tracking**: Handle multiple subarrays with same sum\n4. **Negative Numbers**: Algorithm works with any integer values\n5. **Space-Time Tradeoff**: O(n) space for O(n) time complexity\n\nImplement efficient algorithms for counting subarrays with specific sum constraints.",
    "input_format": "Array of integers and target sum k",
    "output_format": "Count of subarrays with sum k, algorithm analysis",
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-1000 <= nums[i] <= 1000",
      "-10^7 <= k <= 10^7",
      "Array may contain negative numbers"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def subarraySum(nums, k):\n    from collections import defaultdict\n    \n    count = 0\n    prefix_sum = 0\n    prefix_counts = defaultdict(int)\n    prefix_counts[0] = 1  # Empty prefix\n    \n    for num in nums:\n        prefix_sum += num\n        \n        # Check if prefix_sum - k exists\n        if prefix_sum - k in prefix_counts:\n            count += prefix_counts[prefix_sum - k]\n        \n        # Add current prefix sum\n        prefix_counts[prefix_sum] += 1\n    \n    return count",
        "time_complexity": "O(n)",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use prefix sum with hash map. For each position, check if (current_prefix - k) exists in previous prefix sums.",
    "hints": [
      "Use prefix sum: subarray sum = prefix[j] - prefix[i-1]",
      "Store prefix sum counts in hash map for O(1) lookup",
      "For each position, check if (current_prefix - k) was seen before"
    ],
    "difficulty_score": 7700,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M096",
    "title": "Linked List: Copy List with Random Pointer - Deep Copy Construction",
    "slug": "copy-list-random-pointer",
    "difficulty": "Medium",
    "points": 7750,
    "topics": ["Linked List", "Hash Map", "Deep Copy"],
    "tags": ["linked-list", "deep-copy", "random-pointer", "hash-map", "interleaving-nodes"],
    "statement_markdown": "Master **Deep copying linked lists with complex pointer structures**:\n\n1. **Hash Map Approach**: Two-pass solution with node mapping\n2. **Interleaving Technique**: Space-optimized single-pass solution\n3. **Pointer Management**: Handle both next and random connections\n4. **Deep Copy Semantics**: Create completely independent copy\n5. **Edge Case Handling**: Null pointers, self-references, cycles\n\nImplement efficient algorithms for deep copying complex linked list structures.",
    "input_format": "Linked list with next and random pointers",
    "output_format": "Deep copy of original list, pointer analysis",
    "constraints": [
      "0 <= n <= 1000",
      "-10^4 <= Node.val <= 10^4",
      "Node.random is null or points to existing node",
      "All node values are unique"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def copyRandomList(head):\n    if not head:\n        return None\n    \n    # Create mapping old -> new\n    mapping = {}\n    \n    # First pass: create all nodes\n    curr = head\n    while curr:\n        mapping[curr] = Node(curr.val)\n        curr = curr.next\n    \n    # Second pass: set pointers\n    curr = head\n    while curr:\n        if curr.next:\n            mapping[curr].next = mapping[curr.next]\n        if curr.random:\n            mapping[curr].random = mapping[curr.random]\n        curr = curr.next\n    \n    return mapping[head]",
        "time_complexity": "O(n)",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use hash map for oldânew node mapping. First pass creates nodes, second pass sets all pointers using the mapping.",
    "hints": [
      "Use hash map to track correspondence between old and new nodes",
      "Two passes: first create all nodes, second set all pointers",
      "Alternative: interleave new nodes to avoid extra space"
    ],
    "difficulty_score": 7750,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M097",
    "title": "Graph Algorithm: Connected Components - Union-Find & DFS Analysis",
    "slug": "connected-components-undirected-graph",
    "difficulty": "Medium",
    "points": 7800,
    "topics": ["Graph", "Union-Find", "DFS", "BFS"],
    "tags": ["connected-components", "union-find", "dfs", "graph-traversal", "component-counting"],
    "statement_markdown": "Master **Graph connectivity analysis and component counting**:\n\n1. **DFS/BFS Approach**: Traverse graph to identify connected regions\n2. **Union-Find Solution**: Efficiently merge and count components\n3. **Component Labeling**: Assign unique identifiers to each component\n4. **Optimization Techniques**: Path compression and union by rank\n5. **Dynamic Connectivity**: Handle edge additions/removals\n\nImplement efficient algorithms for analyzing graph connectivity and counting components.",
    "input_format": "Number of nodes and list of undirected edges",
    "output_format": "Number of connected components, component analysis",
    "constraints": [
      "1 <= n <= 2000",
      "1 <= edges.length <= 5000",
      "edges[i].length == 2",
      "0 <= ai, bi < n",
      "ai != bi (no self-loops)"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def countComponents(n, edges):\n    parent = list(range(n))\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px != py:\n            parent[px] = py\n    \n    for a, b in edges:\n        union(a, b)\n    \n    return len(set(find(i) for i in range(n)))",
        "time_complexity": "O(E * Î±(V)) for Union-Find, O(V + E) for DFS",
        "space_complexity": "O(V)"
      }
    },
    "editorial": "Use Union-Find with path compression or DFS/BFS traversal. Count unique components by tracking visited nodes or root parents.",
    "hints": [
      "Union-Find: merge connected nodes, count unique root parents",
      "DFS alternative: start traversal from each unvisited node",
      "Path compression optimizes Union-Find performance"
    ],
    "difficulty_score": 7800,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M098",
    "title": "Topological Sort: Alien Dictionary - Character Order Inference",
    "slug": "alien-dictionary-topological-sort",
    "difficulty": "Medium",
    "points": 7850,
    "topics": ["Topological Sort", "Graph", "DFS"],
    "tags": ["alien-dictionary", "topological-sort", "character-ordering", "dfs", "graph-construction"],
    "statement_markdown": "Master **Topological sorting for character order inference**:\n\n1. **Graph Construction**: Build precedence graph from word comparisons\n2. **Edge Detection**: Compare adjacent words to find character ordering\n3. **Cycle Detection**: Validate consistency of derived ordering\n4. **DFS Topological Sort**: Generate valid character sequence\n5. **Edge Case Handling**: Invalid orderings, insufficient information\n\nImplement efficient algorithms for inferring character orderings from sorted word lists.",
    "input_format": "Array of words in alien dictionary order",
    "output_format": "Valid character ordering or empty if impossible",
    "constraints": [
      "1 <= words.length <= 100",
      "1 <= words[i].length <= 20",
      "order is a permutation of all 26 lowercase English letters",
      "words[i] consists of only lowercase English letters"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def alienOrder(words):\n    from collections import defaultdict, deque\n    \n    graph = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    \n    # Build graph\n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i + 1]\n        min_len = min(len(w1), len(w2))\n        \n        if len(w1) > len(w2) and w1[:min_len] == w2[:min_len]:\n            return \"\"  # Invalid case\n        \n        for j in range(min_len):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    in_degree[w2[j]] += 1\n                break\n    \n    # Topological sort\n    queue = deque([c for c in in_degree if in_degree[c] == 0])\n    result = []\n    \n    while queue:\n        c = queue.popleft()\n        result.append(c)\n        for neighbor in graph[c]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return \"\".join(result) if len(result) == len(in_degree) else \"\"",
        "time_complexity": "O(C) where C is total characters in all words",
        "space_complexity": "O(1) for alphabet size"
      }
    },
    "editorial": "Build precedence graph by comparing adjacent words. Use Kahn's algorithm or DFS for topological sorting with cycle detection.",
    "hints": [
      "Compare adjacent words character by character to build precedence graph",
      "Use topological sort (Kahn's algorithm) to generate ordering",
      "Handle edge cases: cycles, invalid prefix relationships"
    ],
    "difficulty_score": 7850,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M099",
    "title": "Monotonic Stack: Next Greater Element - Efficient Range Queries",
    "slug": "next-greater-element-monotonic-stack",
    "difficulty": "Medium",
    "points": 7900,
    "topics": ["Monotonic Stack", "Array"],
    "tags": ["next-greater-element", "monotonic-stack", "circular-array", "stack-optimization", "range-queries"],
    "statement_markdown": "Master **Monotonic stack for efficient range element queries**:\n\n1. **Basic Next Greater**: Find next larger element for each position\n2. **Circular Array Handling**: Process array as if it wraps around\n3. **Multiple Array Queries**: Handle queries across different arrays\n4. **Stack Maintenance**: Keep decreasing sequence for O(n) solution\n5. **Optimization Techniques**: Single pass with stack-based lookups\n\nImplement efficient monotonic stack algorithms for next/previous greater/smaller element problems.",
    "input_format": "Array(s) of integers for next greater element queries",
    "output_format": "Array of next greater elements, algorithm analysis",
    "constraints": [
      "1 <= nums.length <= 10^4",
      "0 <= nums[i] <= 10^9",
      "Array may be circular",
      "Handle multiple query arrays"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "def nextGreaterElement(nums):\n    result = [-1] * len(nums)\n    stack = []\n    \n    for i in range(len(nums)):\n        while stack and nums[stack[-1]] < nums[i]:\n            idx = stack.pop()\n            result[idx] = nums[i]\n        stack.append(i)\n    \n    return result\n\ndef nextGreaterElementsCircular(nums):\n    n = len(nums)\n    result = [-1] * n\n    stack = []\n    \n    for i in range(2 * n):\n        while stack and nums[stack[-1]] < nums[i % n]:\n            idx = stack.pop()\n            result[idx] = nums[i % n]\n        if i < n:\n            stack.append(i)\n    \n    return result",
        "time_complexity": "O(n)",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use monotonic decreasing stack. Process elements left to right, maintaining stack of indices with decreasing values.",
    "hints": [
      "Use monotonic stack to maintain decreasing sequence of elements",
      "For each element, pop smaller elements and set their next greater",
      "For circular arrays, process array twice with modulo indexing"
    ],
    "difficulty_score": 7900,
    "created_by": "system",
    "status": "active"
  },
  {
    "id": "M100",
    "title": "Heap: Find Median from Data Stream - Two Heap Design",
    "slug": "find-median-data-stream",
    "difficulty": "Medium",
    "points": 7950,
    "topics": ["Heap", "Data Stream", "Design"],
    "tags": ["median-finder", "two-heaps", "data-stream", "max-heap", "min-heap"],
    "statement_markdown": "Master **Dual heap data structure for dynamic median queries**:\n\n1. **Two Heap Design**: Max-heap for smaller half, min-heap for larger half\n2. **Balance Maintenance**: Keep heap sizes differ by at most 1\n3. **Efficient Insertion**: O(log n) add operations with rebalancing\n4. **Constant Median**: O(1) median retrieval from heap tops\n5. **Memory Optimization**: Handle continuous data stream efficiently\n\nImplement efficient data structure for finding median in dynamic data streams.",
    "input_format": "Stream of integers with addNum and findMedian operations",
    "output_format": "Median values, heap balance analysis, operation complexity",
    "constraints": [
      "-10^5 <= num <= 10^5",
      "At most 5 * 10^4 calls to addNum and findMedian",
      "All integers from data stream are in range [-10^5, 10^5]"
    ],
    "time_limit_ms": 3000,
    "memory_limit_mb": 128,
    "languages_allowed": ["Python", "Java", "C++", "JavaScript"],
    "checker_type": "exact",
    "custom_checker_code": null,
    "test_cases": [
      {"input": [[1,2,3], 2], "output": 1, "type": "public"},
      {"input": [[4,5,6], 5], "output": 1, "type": "public"},
      {"input": [[], 0], "output": -1, "type": "hidden"},
      {"input": [[1], 1], "output": 0, "type": "hidden"},
      {"input": [[1,2], 3], "output": -1, "type": "edge"},
      {"input": [[10,20,30], 20], "output": 1, "type": "edge"}
    ],
    "partial_scoring": true,
    "grading_rules": {
      "public_testcase_points": 100,
      "hidden_testcase_points": 200,
      "algorithm_efficiency": 50
    },
    "canonical_solution": {
      "Python": {
        "code": "import heapq\n\nclass MedianFinder:\n    def __init__(self):\n        self.max_heap = []  # smaller half (negate values)\n        self.min_heap = []  # larger half\n    \n    def addNum(self, num):\n        # Add to max_heap first\n        heapq.heappush(self.max_heap, -num)\n        \n        # Move max element to min_heap\n        heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap))\n        \n        # Balance heaps\n        if len(self.min_heap) > len(self.max_heap):\n            heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap))\n    \n    def findMedian(self):\n        if len(self.max_heap) > len(self.min_heap):\n            return -self.max_heap[0]\n        return (-self.max_heap[0] + self.min_heap[0]) / 2.0",
        "time_complexity": "O(log n) for addNum, O(1) for findMedian",
        "space_complexity": "O(n)"
      }
    },
    "editorial": "Use two heaps: max-heap for smaller half, min-heap for larger half. Maintain balance so median is always accessible from heap tops.",
    "hints": [
      "Use max-heap for smaller half, min-heap for larger half of numbers",
      "Keep heap sizes balanced: differ by at most 1",
      "Median is either top of larger heap or average of both tops"
    ],
    "difficulty_score": 7950,
    "created_by": "system",
    "status": "active"
  }
]